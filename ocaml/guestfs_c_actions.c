/* libguestfs generated file
 * WARNING: THIS FILE IS GENERATED BY 'src/generator.ml'.
 * ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.
 *
 * Copyright (C) 2009 Red Hat Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <caml/config.h>
#include <caml/alloc.h>
#include <caml/callback.h>
#include <caml/fail.h>
#include <caml/memory.h>
#include <caml/mlvalues.h>
#include <caml/signals.h>

#include <guestfs.h>

#include "guestfs_c.h"

static CAMLprim value
copy_lvm_pv (const struct guestfs_lvm_pv *pv)
{
  CAMLparam0 ();
  CAMLlocal2 (rv, v);

  rv = caml_alloc (14, 0);
  v = caml_copy_string (pv->pv_name);
  Store_field (rv, 0, v);
  v = caml_alloc_string (32);
  memcpy (String_val (v), pv->pv_uuid, 32);
  Store_field (rv, 1, v);
  v = caml_copy_string (pv->pv_fmt);
  Store_field (rv, 2, v);
  v = caml_copy_int64 (pv->pv_size);
  Store_field (rv, 3, v);
  v = caml_copy_int64 (pv->dev_size);
  Store_field (rv, 4, v);
  v = caml_copy_int64 (pv->pv_free);
  Store_field (rv, 5, v);
  v = caml_copy_int64 (pv->pv_used);
  Store_field (rv, 6, v);
  v = caml_copy_string (pv->pv_attr);
  Store_field (rv, 7, v);
  v = caml_copy_int64 (pv->pv_pe_count);
  Store_field (rv, 8, v);
  v = caml_copy_int64 (pv->pv_pe_alloc_count);
  Store_field (rv, 9, v);
  v = caml_copy_string (pv->pv_tags);
  Store_field (rv, 10, v);
  v = caml_copy_int64 (pv->pe_start);
  Store_field (rv, 11, v);
  v = caml_copy_int64 (pv->pv_mda_count);
  Store_field (rv, 12, v);
  v = caml_copy_int64 (pv->pv_mda_free);
  Store_field (rv, 13, v);
  CAMLreturn (rv);
}

static CAMLprim value
copy_lvm_pv_list (const struct guestfs_lvm_pv_list *pvs)
{
  CAMLparam0 ();
  CAMLlocal2 (rv, v);
  int i;

  if (pvs->len == 0)
    CAMLreturn (Atom (0));
  else {
    rv = caml_alloc (pvs->len, 0);
    for (i = 0; i < pvs->len; ++i) {
      v = copy_lvm_pv (&pvs->val[i]);
      caml_modify (&Field (rv, i), v);
    }
    CAMLreturn (rv);
  }
}

static CAMLprim value
copy_lvm_vg (const struct guestfs_lvm_vg *vg)
{
  CAMLparam0 ();
  CAMLlocal2 (rv, v);

  rv = caml_alloc (19, 0);
  v = caml_copy_string (vg->vg_name);
  Store_field (rv, 0, v);
  v = caml_alloc_string (32);
  memcpy (String_val (v), vg->vg_uuid, 32);
  Store_field (rv, 1, v);
  v = caml_copy_string (vg->vg_fmt);
  Store_field (rv, 2, v);
  v = caml_copy_string (vg->vg_attr);
  Store_field (rv, 3, v);
  v = caml_copy_int64 (vg->vg_size);
  Store_field (rv, 4, v);
  v = caml_copy_int64 (vg->vg_free);
  Store_field (rv, 5, v);
  v = caml_copy_string (vg->vg_sysid);
  Store_field (rv, 6, v);
  v = caml_copy_int64 (vg->vg_extent_size);
  Store_field (rv, 7, v);
  v = caml_copy_int64 (vg->vg_extent_count);
  Store_field (rv, 8, v);
  v = caml_copy_int64 (vg->vg_free_count);
  Store_field (rv, 9, v);
  v = caml_copy_int64 (vg->max_lv);
  Store_field (rv, 10, v);
  v = caml_copy_int64 (vg->max_pv);
  Store_field (rv, 11, v);
  v = caml_copy_int64 (vg->pv_count);
  Store_field (rv, 12, v);
  v = caml_copy_int64 (vg->lv_count);
  Store_field (rv, 13, v);
  v = caml_copy_int64 (vg->snap_count);
  Store_field (rv, 14, v);
  v = caml_copy_int64 (vg->vg_seqno);
  Store_field (rv, 15, v);
  v = caml_copy_string (vg->vg_tags);
  Store_field (rv, 16, v);
  v = caml_copy_int64 (vg->vg_mda_count);
  Store_field (rv, 17, v);
  v = caml_copy_int64 (vg->vg_mda_free);
  Store_field (rv, 18, v);
  CAMLreturn (rv);
}

static CAMLprim value
copy_lvm_vg_list (const struct guestfs_lvm_vg_list *vgs)
{
  CAMLparam0 ();
  CAMLlocal2 (rv, v);
  int i;

  if (vgs->len == 0)
    CAMLreturn (Atom (0));
  else {
    rv = caml_alloc (vgs->len, 0);
    for (i = 0; i < vgs->len; ++i) {
      v = copy_lvm_vg (&vgs->val[i]);
      caml_modify (&Field (rv, i), v);
    }
    CAMLreturn (rv);
  }
}

static CAMLprim value
copy_lvm_lv (const struct guestfs_lvm_lv *lv)
{
  CAMLparam0 ();
  CAMLlocal3 (rv, v, v2);

  rv = caml_alloc (16, 0);
  v = caml_copy_string (lv->lv_name);
  Store_field (rv, 0, v);
  v = caml_alloc_string (32);
  memcpy (String_val (v), lv->lv_uuid, 32);
  Store_field (rv, 1, v);
  v = caml_copy_string (lv->lv_attr);
  Store_field (rv, 2, v);
  v = caml_copy_int64 (lv->lv_major);
  Store_field (rv, 3, v);
  v = caml_copy_int64 (lv->lv_minor);
  Store_field (rv, 4, v);
  v = caml_copy_int64 (lv->lv_kernel_major);
  Store_field (rv, 5, v);
  v = caml_copy_int64 (lv->lv_kernel_minor);
  Store_field (rv, 6, v);
  v = caml_copy_int64 (lv->lv_size);
  Store_field (rv, 7, v);
  v = caml_copy_int64 (lv->seg_count);
  Store_field (rv, 8, v);
  v = caml_copy_string (lv->origin);
  Store_field (rv, 9, v);
  if (lv->snap_percent >= 0) { /* Some snap_percent */
    v2 = caml_copy_double (lv->snap_percent);
    v = caml_alloc (1, 0);
    Store_field (v, 0, v2);
  } else /* None */
    v = Val_int (0);
  Store_field (rv, 10, v);
  if (lv->copy_percent >= 0) { /* Some copy_percent */
    v2 = caml_copy_double (lv->copy_percent);
    v = caml_alloc (1, 0);
    Store_field (v, 0, v2);
  } else /* None */
    v = Val_int (0);
  Store_field (rv, 11, v);
  v = caml_copy_string (lv->move_pv);
  Store_field (rv, 12, v);
  v = caml_copy_string (lv->lv_tags);
  Store_field (rv, 13, v);
  v = caml_copy_string (lv->mirror_log);
  Store_field (rv, 14, v);
  v = caml_copy_string (lv->modules);
  Store_field (rv, 15, v);
  CAMLreturn (rv);
}

static CAMLprim value
copy_lvm_lv_list (const struct guestfs_lvm_lv_list *lvs)
{
  CAMLparam0 ();
  CAMLlocal2 (rv, v);
  int i;

  if (lvs->len == 0)
    CAMLreturn (Atom (0));
  else {
    rv = caml_alloc (lvs->len, 0);
    for (i = 0; i < lvs->len; ++i) {
      v = copy_lvm_lv (&lvs->val[i]);
      caml_modify (&Field (rv, i), v);
    }
    CAMLreturn (rv);
  }
}

CAMLprim value
ocaml_guestfs_launch (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("launch: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_launch (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "launch");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_wait_ready (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("wait_ready: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_wait_ready (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "wait_ready");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_kill_subprocess (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("kill_subprocess: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_kill_subprocess (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "kill_subprocess");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_add_drive (value gv, value filenamev)
{
  CAMLparam2 (gv, filenamev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("add_drive: used handle after closing it");

  const char *filename = String_val (filenamev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_add_drive (g, filename);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "add_drive");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_add_cdrom (value gv, value filenamev)
{
  CAMLparam2 (gv, filenamev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("add_cdrom: used handle after closing it");

  const char *filename = String_val (filenamev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_add_cdrom (g, filename);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "add_cdrom");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_config (value gv, value qemuparamv, value qemuvaluev)
{
  CAMLparam3 (gv, qemuparamv, qemuvaluev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("config: used handle after closing it");

  const char *qemuparam = String_val (qemuparamv);
  const char *qemuvalue =
    qemuvaluev != Val_int (0) ? String_val (Field (qemuvaluev, 0)) : NULL;
  int r;

  caml_enter_blocking_section ();
  r = guestfs_config (g, qemuparam, qemuvalue);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "config");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_set_path (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("set_path: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_set_path (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "set_path");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_get_path (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("get_path: used handle after closing it");

  const char *r;

  caml_enter_blocking_section ();
  r = guestfs_get_path (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "get_path");

  rv = caml_copy_string (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_set_autosync (value gv, value autosyncv)
{
  CAMLparam2 (gv, autosyncv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("set_autosync: used handle after closing it");

  int autosync = Bool_val (autosyncv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_set_autosync (g, autosync);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "set_autosync");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_get_autosync (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("get_autosync: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_get_autosync (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "get_autosync");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_set_verbose (value gv, value verbosev)
{
  CAMLparam2 (gv, verbosev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("set_verbose: used handle after closing it");

  int verbose = Bool_val (verbosev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_set_verbose (g, verbose);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "set_verbose");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_get_verbose (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("get_verbose: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_get_verbose (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "get_verbose");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mount (value gv, value devicev, value mountpointv)
{
  CAMLparam3 (gv, devicev, mountpointv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mount: used handle after closing it");

  const char *device = String_val (devicev);
  const char *mountpoint = String_val (mountpointv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mount (g, device, mountpoint);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mount");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_sync (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("sync: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_sync (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "sync");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_touch (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("touch: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_touch (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "touch");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_cat (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("cat: used handle after closing it");

  const char *path = String_val (pathv);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_cat (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "cat");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_ll (value gv, value directoryv)
{
  CAMLparam2 (gv, directoryv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("ll: used handle after closing it");

  const char *directory = String_val (directoryv);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_ll (g, directory);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "ll");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_ls (value gv, value directoryv)
{
  CAMLparam2 (gv, directoryv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("ls: used handle after closing it");

  const char *directory = String_val (directoryv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_ls (g, directory);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "ls");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_list_devices (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("list_devices: used handle after closing it");

  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_list_devices (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "list_devices");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_list_partitions (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("list_partitions: used handle after closing it");

  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_list_partitions (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "list_partitions");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_pvs (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("pvs: used handle after closing it");

  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_pvs (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "pvs");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_vgs (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("vgs: used handle after closing it");

  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_vgs (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "vgs");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_lvs (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("lvs: used handle after closing it");

  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_lvs (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "lvs");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_pvs_full (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("pvs_full: used handle after closing it");

  struct guestfs_lvm_pv_list *r;

  caml_enter_blocking_section ();
  r = guestfs_pvs_full (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "pvs_full");

  rv = copy_lvm_pv_list (r);
  guestfs_free_lvm_pv_list (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_vgs_full (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("vgs_full: used handle after closing it");

  struct guestfs_lvm_vg_list *r;

  caml_enter_blocking_section ();
  r = guestfs_vgs_full (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "vgs_full");

  rv = copy_lvm_vg_list (r);
  guestfs_free_lvm_vg_list (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_lvs_full (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("lvs_full: used handle after closing it");

  struct guestfs_lvm_lv_list *r;

  caml_enter_blocking_section ();
  r = guestfs_lvs_full (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "lvs_full");

  rv = copy_lvm_lv_list (r);
  guestfs_free_lvm_lv_list (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_read_lines (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("read_lines: used handle after closing it");

  const char *path = String_val (pathv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_read_lines (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "read_lines");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_init (value gv, value rootv, value flagsv)
{
  CAMLparam3 (gv, rootv, flagsv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_init: used handle after closing it");

  const char *root = String_val (rootv);
  int flags = Int_val (flagsv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_init (g, root, flags);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_init");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_close (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_close: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_close (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_close");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_defvar (value gv, value namev, value exprv)
{
  CAMLparam3 (gv, namev, exprv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_defvar: used handle after closing it");

  const char *name = String_val (namev);
  const char *expr =
    exprv != Val_int (0) ? String_val (Field (exprv, 0)) : NULL;
  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_defvar (g, name, expr);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_defvar");

  rv = Val_int (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_defnode (value gv, value namev, value exprv, value valv)
{
  CAMLparam4 (gv, namev, exprv, valv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_defnode: used handle after closing it");

  const char *name = String_val (namev);
  const char *expr = String_val (exprv);
  const char *val = String_val (valv);
  struct guestfs_int_bool *r;

  caml_enter_blocking_section ();
  r = guestfs_aug_defnode (g, name, expr, val);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "aug_defnode");

  rv = caml_alloc (2, 0);
  Store_field (rv, 0, Val_int (r->i));
  Store_field (rv, 1, Val_bool (r->b));
  guestfs_free_int_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_get (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_get: used handle after closing it");

  const char *path = String_val (pathv);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_aug_get (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "aug_get");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_set (value gv, value pathv, value valv)
{
  CAMLparam3 (gv, pathv, valv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_set: used handle after closing it");

  const char *path = String_val (pathv);
  const char *val = String_val (valv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_set (g, path, val);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_set");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_insert (value gv, value pathv, value labelv, value beforev)
{
  CAMLparam4 (gv, pathv, labelv, beforev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_insert: used handle after closing it");

  const char *path = String_val (pathv);
  const char *label = String_val (labelv);
  int before = Bool_val (beforev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_insert (g, path, label, before);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_insert");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_rm (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_rm: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_rm (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_rm");

  rv = Val_int (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_mv (value gv, value srcv, value destv)
{
  CAMLparam3 (gv, srcv, destv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_mv: used handle after closing it");

  const char *src = String_val (srcv);
  const char *dest = String_val (destv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_mv (g, src, dest);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_mv");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_match (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_match: used handle after closing it");

  const char *path = String_val (pathv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_aug_match (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "aug_match");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_save (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_save: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_save (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_save");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_load (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_load: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_aug_load (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "aug_load");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_aug_ls (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("aug_ls: used handle after closing it");

  const char *path = String_val (pathv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_aug_ls (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "aug_ls");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_rm (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("rm: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_rm (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "rm");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_rmdir (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("rmdir: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_rmdir (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "rmdir");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_rm_rf (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("rm_rf: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_rm_rf (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "rm_rf");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mkdir (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mkdir: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mkdir (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mkdir");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mkdir_p (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mkdir_p: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mkdir_p (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mkdir_p");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_chmod (value gv, value modev, value pathv)
{
  CAMLparam3 (gv, modev, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("chmod: used handle after closing it");

  int mode = Int_val (modev);
  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_chmod (g, mode, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "chmod");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_chown (value gv, value ownerv, value groupv, value pathv)
{
  CAMLparam4 (gv, ownerv, groupv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("chown: used handle after closing it");

  int owner = Int_val (ownerv);
  int group = Int_val (groupv);
  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_chown (g, owner, group, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "chown");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_exists (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("exists: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_exists (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "exists");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_is_file (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("is_file: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_is_file (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "is_file");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_is_dir (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("is_dir: used handle after closing it");

  const char *path = String_val (pathv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_is_dir (g, path);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "is_dir");

  rv = Val_bool (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_pvcreate (value gv, value devicev)
{
  CAMLparam2 (gv, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("pvcreate: used handle after closing it");

  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_pvcreate (g, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "pvcreate");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_vgcreate (value gv, value volgroupv, value physvolsv)
{
  CAMLparam3 (gv, volgroupv, physvolsv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("vgcreate: used handle after closing it");

  const char *volgroup = String_val (volgroupv);
  char **physvols = ocaml_guestfs_strings_val (physvolsv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_vgcreate (g, volgroup, physvols);
  caml_leave_blocking_section ();
  ocaml_guestfs_free_strings (physvols);
  if (r == -1)
    ocaml_guestfs_raise_error (g, "vgcreate");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_lvcreate (value gv, value logvolv, value volgroupv, value mbytesv)
{
  CAMLparam4 (gv, logvolv, volgroupv, mbytesv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("lvcreate: used handle after closing it");

  const char *logvol = String_val (logvolv);
  const char *volgroup = String_val (volgroupv);
  int mbytes = Int_val (mbytesv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_lvcreate (g, logvol, volgroup, mbytes);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "lvcreate");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mkfs (value gv, value fstypev, value devicev)
{
  CAMLparam3 (gv, fstypev, devicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mkfs: used handle after closing it");

  const char *fstype = String_val (fstypev);
  const char *device = String_val (devicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_mkfs (g, fstype, device);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "mkfs");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_sfdisk (value gv, value devicev, value cylsv, value headsv, value sectorsv, value linesv)
{
  CAMLparam5 (gv, devicev, cylsv, headsv, sectorsv);
  CAMLxparam1 (linesv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("sfdisk: used handle after closing it");

  const char *device = String_val (devicev);
  int cyls = Int_val (cylsv);
  int heads = Int_val (headsv);
  int sectors = Int_val (sectorsv);
  char **lines = ocaml_guestfs_strings_val (linesv);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_sfdisk (g, device, cyls, heads, sectors, lines);
  caml_leave_blocking_section ();
  ocaml_guestfs_free_strings (lines);
  if (r == -1)
    ocaml_guestfs_raise_error (g, "sfdisk");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_sfdisk_byte (value *argv, int argn)
{
  return ocaml_guestfs_sfdisk (argv[0], argv[0], argv[1], argv[2], argv[3], argv[4]);
}

CAMLprim value
ocaml_guestfs_write_file (value gv, value pathv, value contentv, value sizev)
{
  CAMLparam4 (gv, pathv, contentv, sizev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("write_file: used handle after closing it");

  const char *path = String_val (pathv);
  const char *content = String_val (contentv);
  int size = Int_val (sizev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_write_file (g, path, content, size);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "write_file");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_umount (value gv, value pathordevicev)
{
  CAMLparam2 (gv, pathordevicev);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("umount: used handle after closing it");

  const char *pathordevice = String_val (pathordevicev);
  int r;

  caml_enter_blocking_section ();
  r = guestfs_umount (g, pathordevice);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "umount");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_mounts (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("mounts: used handle after closing it");

  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_mounts (g);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "mounts");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_umount_all (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("umount_all: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_umount_all (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "umount_all");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_lvm_remove_all (value gv)
{
  CAMLparam1 (gv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("lvm_remove_all: used handle after closing it");

  int r;

  caml_enter_blocking_section ();
  r = guestfs_lvm_remove_all (g);
  caml_leave_blocking_section ();
  if (r == -1)
    ocaml_guestfs_raise_error (g, "lvm_remove_all");

  rv = Val_unit;
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_file (value gv, value pathv)
{
  CAMLparam2 (gv, pathv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("file: used handle after closing it");

  const char *path = String_val (pathv);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_file (g, path);
  caml_leave_blocking_section ();
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "file");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_command (value gv, value argumentsv)
{
  CAMLparam2 (gv, argumentsv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("command: used handle after closing it");

  char **arguments = ocaml_guestfs_strings_val (argumentsv);
  char *r;

  caml_enter_blocking_section ();
  r = guestfs_command (g, arguments);
  caml_leave_blocking_section ();
  ocaml_guestfs_free_strings (arguments);
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "command");

  rv = caml_copy_string (r);
  free (r);
  CAMLreturn (rv);
}

CAMLprim value
ocaml_guestfs_command_lines (value gv, value argumentsv)
{
  CAMLparam2 (gv, argumentsv);
  CAMLlocal1 (rv);

  guestfs_h *g = Guestfs_val (gv);
  if (g == NULL)
    caml_failwith ("command_lines: used handle after closing it");

  char **arguments = ocaml_guestfs_strings_val (argumentsv);
  int i;
  char **r;

  caml_enter_blocking_section ();
  r = guestfs_command_lines (g, arguments);
  caml_leave_blocking_section ();
  ocaml_guestfs_free_strings (arguments);
  if (r == NULL)
    ocaml_guestfs_raise_error (g, "command_lines");

  rv = caml_copy_string_array ((const char **) r);
  for (i = 0; r[i] != NULL; ++i) free (r[i]);
  free (r);
  CAMLreturn (rv);
}

