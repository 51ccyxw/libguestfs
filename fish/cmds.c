/* libguestfs generated file
 * WARNING: THIS FILE IS GENERATED BY 'src/generator.ml'.
 * ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.
 *
 * Copyright (C) 2009 Red Hat Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>

#include <guestfs.h>
#include "fish.h"

void list_commands (void)
{
  printf ("    %-16s     %s\n", "Command", "Description");
  list_builtin_commands ();
  printf ("%-20s %s\n", "add-cdrom", "add a CD-ROM disk image to examine");
  printf ("%-20s %s\n", "add-drive", "add an image to examine or modify");
  printf ("%-20s %s\n", "aug-close", "close the current Augeas handle");
  printf ("%-20s %s\n", "aug-defnode", "define an Augeas node");
  printf ("%-20s %s\n", "aug-defvar", "define an Augeas variable");
  printf ("%-20s %s\n", "aug-get", "look up the value of an Augeas path");
  printf ("%-20s %s\n", "aug-init", "create a new Augeas handle");
  printf ("%-20s %s\n", "aug-insert", "insert a sibling Augeas node");
  printf ("%-20s %s\n", "aug-load", "load files into the tree");
  printf ("%-20s %s\n", "aug-match", "return Augeas nodes which match path");
  printf ("%-20s %s\n", "aug-mv", "move Augeas node");
  printf ("%-20s %s\n", "aug-rm", "remove an Augeas path");
  printf ("%-20s %s\n", "aug-save", "write all pending Augeas changes to disk");
  printf ("%-20s %s\n", "aug-set", "set Augeas path to value");
  printf ("%-20s %s\n", "cat", "list the contents of a file");
  printf ("%-20s %s\n", "config", "add qemu parameters");
  printf ("%-20s %s\n", "get-autosync", "get autosync mode");
  printf ("%-20s %s\n", "get-path", "get the search path");
  printf ("%-20s %s\n", "get-verbose", "get verbose mode");
  printf ("%-20s %s\n", "kill-subprocess", "kill the qemu subprocess");
  printf ("%-20s %s\n", "launch", "launch the qemu subprocess");
  printf ("%-20s %s\n", "list-devices", "list the block devices");
  printf ("%-20s %s\n", "list-partitions", "list the partitions");
  printf ("%-20s %s\n", "ll", "list the files in a directory (long format)");
  printf ("%-20s %s\n", "ls", "list the files in a directory");
  printf ("%-20s %s\n", "lvs", "list the LVM logical volumes (LVs)");
  printf ("%-20s %s\n", "lvs-full", "list the LVM logical volumes (LVs)");
  printf ("%-20s %s\n", "mount", "mount a guest disk at a position in the filesystem");
  printf ("%-20s %s\n", "pvs", "list the LVM physical volumes (PVs)");
  printf ("%-20s %s\n", "pvs-full", "list the LVM physical volumes (PVs)");
  printf ("%-20s %s\n", "read-lines", "read file as lines");
  printf ("%-20s %s\n", "set-autosync", "set autosync mode");
  printf ("%-20s %s\n", "set-path", "set the search path");
  printf ("%-20s %s\n", "set-verbose", "set verbose mode");
  printf ("%-20s %s\n", "sync", "sync disks, writes are flushed through to the disk image");
  printf ("%-20s %s\n", "touch", "update file timestamps or create a new file");
  printf ("%-20s %s\n", "vgs", "list the LVM volume groups (VGs)");
  printf ("%-20s %s\n", "vgs-full", "list the LVM volume groups (VGs)");
  printf ("    Use -h <cmd> / help <cmd> to show detailed help for a command.\n");
}

void display_command (const char *cmd)
{
  if (strcasecmp (cmd, "launch") == 0 || strcasecmp (cmd, "run") == 0)
    pod2text ("launch - launch the qemu subprocess", " launch\n\nInternally libguestfs is implemented by running a virtual machine\nusing L<qemu(1)>.\n\nYou should call this after configuring the handle\n(eg. adding drives) but before performing any actions.\n\nYou can use 'run' as an alias for this command.");
  else
  if (strcasecmp (cmd, "kill_subprocess") == 0 || strcasecmp (cmd, "kill-subprocess") == 0)
    pod2text ("kill-subprocess - kill the qemu subprocess", " kill-subprocess\n\nThis kills the qemu subprocess.  You should never need to call this.");
  else
  if (strcasecmp (cmd, "add_drive") == 0 || strcasecmp (cmd, "add-drive") == 0 || strcasecmp (cmd, "add") == 0)
    pod2text ("add-drive - add an image to examine or modify", " add-drive <filename>\n\nThis function adds a virtual machine disk image C<filename> to the\nguest.  The first time you call this function, the disk appears as IDE\ndisk 0 (C</dev/sda>) in the guest, the second time as C</dev/sdb>, and\nso on.\n\nYou don't necessarily need to be root when using libguestfs.  However\nyou obviously do need sufficient permissions to access the filename\nfor whatever operations you want to perform (ie. read access if you\njust want to read the image or write access if you want to modify the\nimage).\n\nThis is equivalent to the qemu parameter C<-drive file=filename>.\n\nYou can use 'add' as an alias for this command.");
  else
  if (strcasecmp (cmd, "add_cdrom") == 0 || strcasecmp (cmd, "add-cdrom") == 0 || strcasecmp (cmd, "cdrom") == 0)
    pod2text ("add-cdrom - add a CD-ROM disk image to examine", " add-cdrom <filename>\n\nThis function adds a virtual CD-ROM disk image to the guest.\n\nThis is equivalent to the qemu parameter C<-cdrom filename>.\n\nYou can use 'cdrom' as an alias for this command.");
  else
  if (strcasecmp (cmd, "config") == 0)
    pod2text ("config - add qemu parameters", " config <qemuparam> <qemuvalue>\n\nThis can be used to add arbitrary qemu command line parameters\nof the form C<-param value>.  Actually it's not quite arbitrary - we\nprevent you from setting some parameters which would interfere with\nparameters that we use.\n\nThe first character of C<param> string must be a C<-> (dash).\n\nC<value> can be NULL.");
  else
  if (strcasecmp (cmd, "set_path") == 0 || strcasecmp (cmd, "set-path") == 0 || strcasecmp (cmd, "path") == 0)
    pod2text ("set-path - set the search path", " set-path <path>\n\nSet the path that libguestfs searches for kernel and initrd.img.\n\nThe default is C<$libdir/guestfs> unless overridden by setting\nC<LIBGUESTFS_PATH> environment variable.\n\nThe string C<path> is stashed in the libguestfs handle, so the caller\nmust make sure it remains valid for the lifetime of the handle.\n\nSetting C<path> to C<NULL> restores the default path.\n\nYou can use 'path' as an alias for this command.");
  else
  if (strcasecmp (cmd, "get_path") == 0 || strcasecmp (cmd, "get-path") == 0)
    pod2text ("get-path - get the search path", " get-path\n\nReturn the current search path.\n\nThis is always non-NULL.  If it wasn't set already, then this will\nreturn the default path.");
  else
  if (strcasecmp (cmd, "set_autosync") == 0 || strcasecmp (cmd, "set-autosync") == 0 || strcasecmp (cmd, "autosync") == 0)
    pod2text ("set-autosync - set autosync mode", " set-autosync <autosync>\n\nIf C<autosync> is true, this enables autosync.  Libguestfs will make a\nbest effort attempt to run C<sync> when the handle is closed\n(also if the program exits without closing handles).\n\nYou can use 'autosync' as an alias for this command.");
  else
  if (strcasecmp (cmd, "get_autosync") == 0 || strcasecmp (cmd, "get-autosync") == 0)
    pod2text ("get-autosync - get autosync mode", " get-autosync\n\nGet the autosync flag.");
  else
  if (strcasecmp (cmd, "set_verbose") == 0 || strcasecmp (cmd, "set-verbose") == 0 || strcasecmp (cmd, "verbose") == 0)
    pod2text ("set-verbose - set verbose mode", " set-verbose <verbose>\n\nIf C<verbose> is true, this turns on verbose messages (to C<stderr>).\n\nVerbose messages are disabled unless the environment variable\nC<LIBGUESTFS_DEBUG> is defined and set to C<1>.\n\nYou can use 'verbose' as an alias for this command.");
  else
  if (strcasecmp (cmd, "get_verbose") == 0 || strcasecmp (cmd, "get-verbose") == 0)
    pod2text ("get-verbose - get verbose mode", " get-verbose\n\nThis returns the verbose messages flag.");
  else
  if (strcasecmp (cmd, "mount") == 0)
    pod2text ("mount - mount a guest disk at a position in the filesystem", " mount <device> <mountpoint>\n\nMount a guest disk at a position in the filesystem.  Block devices\nare named C</dev/sda>, C</dev/sdb> and so on, as they were added to\nthe guest.  If those block devices contain partitions, they will have\nthe usual names (eg. C</dev/sda1>).  Also LVM C</dev/VG/LV>-style\nnames can be used.\n\nThe rules are the same as for L<mount(2)>:  A filesystem must\nfirst be mounted on C</> before others can be mounted.  Other\nfilesystems can only be mounted on directories which already\nexist.\n\nThe mounted filesystem is writable, if we have sufficient permissions\non the underlying device.\n\nThe filesystem options C<sync> and C<noatime> are set with this\ncall, in order to improve reliability.");
  else
  if (strcasecmp (cmd, "sync") == 0)
    pod2text ("sync - sync disks, writes are flushed through to the disk image", " sync\n\nThis syncs the disk, so that any writes are flushed through to the\nunderlying disk image.\n\nYou should always call this if you have modified a disk image, before\nclosing the handle.");
  else
  if (strcasecmp (cmd, "touch") == 0)
    pod2text ("touch - update file timestamps or create a new file", " touch <path>\n\nTouch acts like the L<touch(1)> command.  It can be used to\nupdate the timestamps on a file, or, if the file does not exist,\nto create a new zero-length file.");
  else
  if (strcasecmp (cmd, "cat") == 0)
    pod2text ("cat - list the contents of a file", " cat <path>\n\nReturn the contents of the file named C<path>.\n\nNote that this function cannot correctly handle binary files\n(specifically, files containing C<\\0> character which is treated\nas end of string).  For those you need to use the C<read_file>\nfunction which has a more complex interface.\n\nBecause of the message protocol, there is a transfer limit \nof somewhere between 2MB and 4MB.  To transfer large files you should use\nFTP.");
  else
  if (strcasecmp (cmd, "ll") == 0)
    pod2text ("ll - list the files in a directory (long format)", " ll <directory>\n\nList the files in C<directory> (relative to the root directory,\nthere is no cwd) in the format of 'ls -la'.\n\nThis command is mostly useful for interactive sessions.  It\nis I<not> intended that you try to parse the output string.");
  else
  if (strcasecmp (cmd, "ls") == 0)
    pod2text ("ls - list the files in a directory", " ls <directory>\n\nList the files in C<directory> (relative to the root directory,\nthere is no cwd).  The '.' and '..' entries are not returned, but\nhidden files are shown.\n\nThis command is mostly useful for interactive sessions.  Programs\nshould probably use C<readdir> instead.");
  else
  if (strcasecmp (cmd, "list_devices") == 0 || strcasecmp (cmd, "list-devices") == 0)
    pod2text ("list-devices - list the block devices", " list-devices\n\nList all the block devices.\n\nThe full block device names are returned, eg. C</dev/sda>");
  else
  if (strcasecmp (cmd, "list_partitions") == 0 || strcasecmp (cmd, "list-partitions") == 0)
    pod2text ("list-partitions - list the partitions", " list-partitions\n\nList all the partitions detected on all block devices.\n\nThe full partition device names are returned, eg. C</dev/sda1>\n\nThis does not return logical volumes.  For that you will need to\ncall C<lvs>.");
  else
  if (strcasecmp (cmd, "pvs") == 0)
    pod2text ("pvs - list the LVM physical volumes (PVs)", " pvs\n\nList all the physical volumes detected.  This is the equivalent\nof the L<pvs(8)> command.\n\nThis returns a list of just the device names that contain\nPVs (eg. C</dev/sda2>).\n\nSee also C<pvs_full>.");
  else
  if (strcasecmp (cmd, "vgs") == 0)
    pod2text ("vgs - list the LVM volume groups (VGs)", " vgs\n\nList all the volumes groups detected.  This is the equivalent\nof the L<vgs(8)> command.\n\nThis returns a list of just the volume group names that were\ndetected (eg. C<VolGroup00>).\n\nSee also C<vgs_full>.");
  else
  if (strcasecmp (cmd, "lvs") == 0)
    pod2text ("lvs - list the LVM logical volumes (LVs)", " lvs\n\nList all the logical volumes detected.  This is the equivalent\nof the L<lvs(8)> command.\n\nThis returns a list of the logical volume device names\n(eg. C</dev/VolGroup00/LogVol00>).\n\nSee also C<lvs_full>.");
  else
  if (strcasecmp (cmd, "pvs_full") == 0 || strcasecmp (cmd, "pvs-full") == 0)
    pod2text ("pvs-full - list the LVM physical volumes (PVs)", " pvs-full\n\nList all the physical volumes detected.  This is the equivalent\nof the L<pvs(8)> command.  The \"full\" version includes all fields.");
  else
  if (strcasecmp (cmd, "vgs_full") == 0 || strcasecmp (cmd, "vgs-full") == 0)
    pod2text ("vgs-full - list the LVM volume groups (VGs)", " vgs-full\n\nList all the volumes groups detected.  This is the equivalent\nof the L<vgs(8)> command.  The \"full\" version includes all fields.");
  else
  if (strcasecmp (cmd, "lvs_full") == 0 || strcasecmp (cmd, "lvs-full") == 0)
    pod2text ("lvs-full - list the LVM logical volumes (LVs)", " lvs-full\n\nList all the logical volumes detected.  This is the equivalent\nof the L<lvs(8)> command.  The \"full\" version includes all fields.");
  else
  if (strcasecmp (cmd, "read_lines") == 0 || strcasecmp (cmd, "read-lines") == 0)
    pod2text ("read-lines - read file as lines", " read-lines <path>\n\nReturn the contents of the file named C<path>.\n\nThe file contents are returned as a list of lines.  Trailing\nC<LF> and C<CRLF> character sequences are I<not> returned.\n\nNote that this function cannot correctly handle binary files\n(specifically, files containing C<\\0> character which is treated\nas end of line).  For those you need to use the C<read_file>\nfunction which has a more complex interface.");
  else
  if (strcasecmp (cmd, "aug_init") == 0 || strcasecmp (cmd, "aug-init") == 0)
    pod2text ("aug-init - create a new Augeas handle", " aug-init <root> <flags>\n\nCreate a new Augeas handle for editing configuration files.\nIf there was any previous Augeas handle associated with this\nguestfs session, then it is closed.\n\nYou must call this before using any other C<aug_*>\ncommands.\n\nC<root> is the filesystem root.  C<root> must not be NULL,\nuse C</> instead.\n\nThe flags are the same as the flags defined in\nE<lt>augeas.hE<gt>, the logical I<or> of the following\nintegers:\n\n=over 4\n\n=item 1 C<AUG_SAVE_BACKUP>\n\nKeep the original file with a C<.augsave> extension.\n\n=item 2 C<AUG_SAVE_NEWFILE>\n\nSave changes into a file with extension C<.augnew>, and\ndo not overwrite original.  Overrides C<AUG_SAVE_BACKUP>.\n\n=item 4 C<AUG_TYPE_CHECK>\n\nTypecheck lenses (can be expensive).\n\n=item 8 C<AUG_NO_STDINC>\n\nDo not use standard load path for modules.\n\n=item 16 C<AUG_SAVE_NOOP>\n\nMake save a no-op, just record what would have been changed.\n\n=item 32 C<AUG_NO_LOAD>\n\nDo not load the tree in C<aug_init>.\n\n=back\n\nTo close the handle, you can call C<aug_close>.\n\nTo find out more about Augeas, see L<http://augeas.net/>.");
  else
  if (strcasecmp (cmd, "aug_close") == 0 || strcasecmp (cmd, "aug-close") == 0)
    pod2text ("aug-close - close the current Augeas handle", " aug-close\n\nClose the current Augeas handle and free up any resources\nused by it.  After calling this, you have to call\nC<aug_init> again before you can use any other\nAugeas functions.");
  else
  if (strcasecmp (cmd, "aug_defvar") == 0 || strcasecmp (cmd, "aug-defvar") == 0)
    pod2text ("aug-defvar - define an Augeas variable", " aug-defvar <name> <expr>\n\nDefines an Augeas variable C<name> whose value is the result\nof evaluating C<expr>.  If C<expr> is NULL, then C<name> is\nundefined.\n\nOn success this returns the number of nodes in C<expr>, or\nC<0> if C<expr> evaluates to something which is not a nodeset.");
  else
  if (strcasecmp (cmd, "aug_defnode") == 0 || strcasecmp (cmd, "aug-defnode") == 0)
    pod2text ("aug-defnode - define an Augeas node", " aug-defnode <name> <expr> <val>\n\nDefines a variable C<name> whose value is the result of\nevaluating C<expr>.\n\nIf C<expr> evaluates to an empty nodeset, a node is created,\nequivalent to calling C<aug_set> C<expr>, C<value>.\nC<name> will be the nodeset containing that single node.\n\nOn success this returns a pair containing the\nnumber of nodes in the nodeset, and a boolean flag\nif a node was created.");
  else
  if (strcasecmp (cmd, "aug_get") == 0 || strcasecmp (cmd, "aug-get") == 0)
    pod2text ("aug-get - look up the value of an Augeas path", " aug-get <path>\n\nLook up the value associated with C<path>.  If C<path>\nmatches exactly one node, the C<value> is returned.");
  else
  if (strcasecmp (cmd, "aug_set") == 0 || strcasecmp (cmd, "aug-set") == 0)
    pod2text ("aug-set - set Augeas path to value", " aug-set <path> <val>\n\nSet the value associated with C<path> to C<value>.");
  else
  if (strcasecmp (cmd, "aug_insert") == 0 || strcasecmp (cmd, "aug-insert") == 0)
    pod2text ("aug-insert - insert a sibling Augeas node", " aug-insert <path> <label> <before>\n\nCreate a new sibling C<label> for C<path>, inserting it into\nthe tree before or after C<path> (depending on the boolean\nflag C<before>).\n\nC<path> must match exactly one existing node in the tree, and\nC<label> must be a label, ie. not contain C</>, C<*> or end\nwith a bracketed index C<[N]>.");
  else
  if (strcasecmp (cmd, "aug_rm") == 0 || strcasecmp (cmd, "aug-rm") == 0)
    pod2text ("aug-rm - remove an Augeas path", " aug-rm <path>\n\nRemove C<path> and all of its children.\n\nOn success this returns the number of entries which were removed.");
  else
  if (strcasecmp (cmd, "aug_mv") == 0 || strcasecmp (cmd, "aug-mv") == 0)
    pod2text ("aug-mv - move Augeas node", " aug-mv <src> <dest>\n\nMove the node C<src> to C<dest>.  C<src> must match exactly\none node.  C<dest> is overwritten if it exists.");
  else
  if (strcasecmp (cmd, "aug_match") == 0 || strcasecmp (cmd, "aug-match") == 0)
    pod2text ("aug-match - return Augeas nodes which match path", " aug-match <path>\n\nReturns a list of paths which match the path expression C<path>.\nThe returned paths are sufficiently qualified so that they match\nexactly one node in the current tree.");
  else
  if (strcasecmp (cmd, "aug_save") == 0 || strcasecmp (cmd, "aug-save") == 0)
    pod2text ("aug-save - write all pending Augeas changes to disk", " aug-save\n\nThis writes all pending changes to disk.\n\nThe flags which were passed to C<aug_init> affect exactly\nhow files are saved.");
  else
  if (strcasecmp (cmd, "aug_load") == 0 || strcasecmp (cmd, "aug-load") == 0)
    pod2text ("aug-load - load files into the tree", " aug-load\n\nLoad files into the tree.\n\nSee C<aug_load> in the Augeas documentation for the full gory\ndetails.");
  else
    display_builtin_command (cmd);
}

static void print_pv (struct guestfs_lvm_pv *pv)
{
  int i;

  printf ("pv_name: %s\n", pv->pv_name);
  printf ("pv_uuid: ");
  for (i = 0; i < 32; ++i)
    printf ("%c", pv->pv_uuid[i]);
  printf ("\n");
  printf ("pv_fmt: %s\n", pv->pv_fmt);
  printf ("pv_size: %" PRIu64 "\n", pv->pv_size);
  printf ("dev_size: %" PRIu64 "\n", pv->dev_size);
  printf ("pv_free: %" PRIu64 "\n", pv->pv_free);
  printf ("pv_used: %" PRIu64 "\n", pv->pv_used);
  printf ("pv_attr: %s\n", pv->pv_attr);
  printf ("pv_pe_count: %" PRIi64 "\n", pv->pv_pe_count);
  printf ("pv_pe_alloc_count: %" PRIi64 "\n", pv->pv_pe_alloc_count);
  printf ("pv_tags: %s\n", pv->pv_tags);
  printf ("pe_start: %" PRIu64 "\n", pv->pe_start);
  printf ("pv_mda_count: %" PRIi64 "\n", pv->pv_mda_count);
  printf ("pv_mda_free: %" PRIu64 "\n", pv->pv_mda_free);
}

static void print_pv_list (struct guestfs_lvm_pv_list *pvs)
{
  int i;

  for (i = 0; i < pvs->len; ++i)
    print_pv (&pvs->val[i]);
}

static void print_vg (struct guestfs_lvm_vg *vg)
{
  int i;

  printf ("vg_name: %s\n", vg->vg_name);
  printf ("vg_uuid: ");
  for (i = 0; i < 32; ++i)
    printf ("%c", vg->vg_uuid[i]);
  printf ("\n");
  printf ("vg_fmt: %s\n", vg->vg_fmt);
  printf ("vg_attr: %s\n", vg->vg_attr);
  printf ("vg_size: %" PRIu64 "\n", vg->vg_size);
  printf ("vg_free: %" PRIu64 "\n", vg->vg_free);
  printf ("vg_sysid: %s\n", vg->vg_sysid);
  printf ("vg_extent_size: %" PRIu64 "\n", vg->vg_extent_size);
  printf ("vg_extent_count: %" PRIi64 "\n", vg->vg_extent_count);
  printf ("vg_free_count: %" PRIi64 "\n", vg->vg_free_count);
  printf ("max_lv: %" PRIi64 "\n", vg->max_lv);
  printf ("max_pv: %" PRIi64 "\n", vg->max_pv);
  printf ("pv_count: %" PRIi64 "\n", vg->pv_count);
  printf ("lv_count: %" PRIi64 "\n", vg->lv_count);
  printf ("snap_count: %" PRIi64 "\n", vg->snap_count);
  printf ("vg_seqno: %" PRIi64 "\n", vg->vg_seqno);
  printf ("vg_tags: %s\n", vg->vg_tags);
  printf ("vg_mda_count: %" PRIi64 "\n", vg->vg_mda_count);
  printf ("vg_mda_free: %" PRIu64 "\n", vg->vg_mda_free);
}

static void print_vg_list (struct guestfs_lvm_vg_list *vgs)
{
  int i;

  for (i = 0; i < vgs->len; ++i)
    print_vg (&vgs->val[i]);
}

static void print_lv (struct guestfs_lvm_lv *lv)
{
  int i;

  printf ("lv_name: %s\n", lv->lv_name);
  printf ("lv_uuid: ");
  for (i = 0; i < 32; ++i)
    printf ("%c", lv->lv_uuid[i]);
  printf ("\n");
  printf ("lv_attr: %s\n", lv->lv_attr);
  printf ("lv_major: %" PRIi64 "\n", lv->lv_major);
  printf ("lv_minor: %" PRIi64 "\n", lv->lv_minor);
  printf ("lv_kernel_major: %" PRIi64 "\n", lv->lv_kernel_major);
  printf ("lv_kernel_minor: %" PRIi64 "\n", lv->lv_kernel_minor);
  printf ("lv_size: %" PRIu64 "\n", lv->lv_size);
  printf ("seg_count: %" PRIi64 "\n", lv->seg_count);
  printf ("origin: %s\n", lv->origin);
  if (lv->snap_percent >= 0) printf ("snap_percent: %g %%\n", lv->snap_percent);
  else printf ("snap_percent: \n");
  if (lv->copy_percent >= 0) printf ("copy_percent: %g %%\n", lv->copy_percent);
  else printf ("copy_percent: \n");
  printf ("move_pv: %s\n", lv->move_pv);
  printf ("lv_tags: %s\n", lv->lv_tags);
  printf ("mirror_log: %s\n", lv->mirror_log);
  printf ("modules: %s\n", lv->modules);
}

static void print_lv_list (struct guestfs_lvm_lv_list *lvs)
{
  int i;

  for (i = 0; i < lvs->len; ++i)
    print_lv (&lvs->val[i]);
}

static int run_launch (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = launch (g);
  return r;
}

static int run_kill_subprocess (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_kill_subprocess (g);
  return r;
}

static int run_add_drive (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *filename;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  filename = argv[0];
  r = guestfs_add_drive (g, filename);
  return r;
}

static int run_add_cdrom (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *filename;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  filename = argv[0];
  r = guestfs_add_cdrom (g, filename);
  return r;
}

static int run_config (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *qemuparam;
  const char *qemuvalue;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  qemuparam = argv[0];
  qemuvalue = strcmp (argv[1], "") != 0 ? argv[1] : NULL;
  r = guestfs_config (g, qemuparam, qemuvalue);
  return r;
}

static int run_set_path (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_set_path (g, path);
  return r;
}

static int run_get_path (const char *cmd, int argc, char *argv[])
{
  const char *r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_get_path (g);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  return 0;
}

static int run_set_autosync (const char *cmd, int argc, char *argv[])
{
  int r;
  int autosync;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  autosync = is_true (argv[0]) ? 1 : 0;
  r = guestfs_set_autosync (g, autosync);
  return r;
}

static int run_get_autosync (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_get_autosync (g);
  if (r == -1) return -1;
  if (r) printf ("true\n"); else printf ("false\n");
  return 0;
}

static int run_set_verbose (const char *cmd, int argc, char *argv[])
{
  int r;
  int verbose;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  verbose = is_true (argv[0]) ? 1 : 0;
  r = guestfs_set_verbose (g, verbose);
  return r;
}

static int run_get_verbose (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_get_verbose (g);
  if (r == -1) return -1;
  if (r) printf ("true\n"); else printf ("false\n");
  return 0;
}

static int run_mount (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  const char *mountpoint;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  mountpoint = argv[1];
  r = guestfs_mount (g, device, mountpoint);
  return r;
}

static int run_sync (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_sync (g);
  return r;
}

static int run_touch (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_touch (g, path);
  return r;
}

static int run_cat (const char *cmd, int argc, char *argv[])
{
  char *r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_cat (g, path);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  free (r);
  return 0;
}

static int run_ll (const char *cmd, int argc, char *argv[])
{
  char *r;
  const char *directory;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  directory = argv[0];
  r = guestfs_ll (g, directory);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  free (r);
  return 0;
}

static int run_ls (const char *cmd, int argc, char *argv[])
{
  char **r;
  const char *directory;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  directory = argv[0];
  r = guestfs_ls (g, directory);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_list_devices (const char *cmd, int argc, char *argv[])
{
  char **r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_list_devices (g);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_list_partitions (const char *cmd, int argc, char *argv[])
{
  char **r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_list_partitions (g);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_pvs (const char *cmd, int argc, char *argv[])
{
  char **r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_pvs (g);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_vgs (const char *cmd, int argc, char *argv[])
{
  char **r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_vgs (g);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_lvs (const char *cmd, int argc, char *argv[])
{
  char **r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_lvs (g);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_pvs_full (const char *cmd, int argc, char *argv[])
{
  struct guestfs_lvm_pv_list *r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_pvs_full (g);
  if (r == NULL) return -1;
  print_pv_list (r);
  guestfs_free_lvm_pv_list (r);
  return 0;
}

static int run_vgs_full (const char *cmd, int argc, char *argv[])
{
  struct guestfs_lvm_vg_list *r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_vgs_full (g);
  if (r == NULL) return -1;
  print_vg_list (r);
  guestfs_free_lvm_vg_list (r);
  return 0;
}

static int run_lvs_full (const char *cmd, int argc, char *argv[])
{
  struct guestfs_lvm_lv_list *r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_lvs_full (g);
  if (r == NULL) return -1;
  print_lv_list (r);
  guestfs_free_lvm_lv_list (r);
  return 0;
}

static int run_read_lines (const char *cmd, int argc, char *argv[])
{
  char **r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_read_lines (g, path);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_aug_init (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *root;
  int flags;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  root = argv[0];
  flags = atoi (argv[1]);
  r = guestfs_aug_init (g, root, flags);
  return r;
}

static int run_aug_close (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_aug_close (g);
  return r;
}

static int run_aug_defvar (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *name;
  const char *expr;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  name = argv[0];
  expr = strcmp (argv[1], "") != 0 ? argv[1] : NULL;
  r = guestfs_aug_defvar (g, name, expr);
  if (r == -1) return -1;
  if (r) printf ("%d\n", r);
  return 0;
}

static int run_aug_defnode (const char *cmd, int argc, char *argv[])
{
  struct guestfs_int_bool *r;
  const char *name;
  const char *expr;
  const char *val;
  if (argc != 3) {
    fprintf (stderr, "%s should have 3 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  name = argv[0];
  expr = argv[1];
  val = argv[2];
  r = guestfs_aug_defnode (g, name, expr, val);
  if (r == NULL) return -1;
  printf ("%d, %s\n", r->i,
    r->b ? "true" : "false");
  guestfs_free_int_bool (r);
  return 0;
}

static int run_aug_get (const char *cmd, int argc, char *argv[])
{
  char *r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_aug_get (g, path);
  if (r == NULL) return -1;
  printf ("%s\n", r);
  free (r);
  return 0;
}

static int run_aug_set (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  const char *val;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  val = argv[1];
  r = guestfs_aug_set (g, path, val);
  return r;
}

static int run_aug_insert (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  const char *label;
  int before;
  if (argc != 3) {
    fprintf (stderr, "%s should have 3 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  label = argv[1];
  before = is_true (argv[2]) ? 1 : 0;
  r = guestfs_aug_insert (g, path, label, before);
  return r;
}

static int run_aug_rm (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_aug_rm (g, path);
  if (r == -1) return -1;
  if (r) printf ("%d\n", r);
  return 0;
}

static int run_aug_mv (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *src;
  const char *dest;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  src = argv[0];
  dest = argv[1];
  r = guestfs_aug_mv (g, src, dest);
  return r;
}

static int run_aug_match (const char *cmd, int argc, char *argv[])
{
  char **r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_aug_match (g, path);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_aug_save (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_aug_save (g);
  return r;
}

static int run_aug_load (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_aug_load (g);
  return r;
}

int run_action (const char *cmd, int argc, char *argv[])
{
  if (strcasecmp (cmd, "launch") == 0 || strcasecmp (cmd, "run") == 0)
    return run_launch (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "kill_subprocess") == 0 || strcasecmp (cmd, "kill-subprocess") == 0)
    return run_kill_subprocess (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "add_drive") == 0 || strcasecmp (cmd, "add-drive") == 0 || strcasecmp (cmd, "add") == 0)
    return run_add_drive (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "add_cdrom") == 0 || strcasecmp (cmd, "add-cdrom") == 0 || strcasecmp (cmd, "cdrom") == 0)
    return run_add_cdrom (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "config") == 0)
    return run_config (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "set_path") == 0 || strcasecmp (cmd, "set-path") == 0 || strcasecmp (cmd, "path") == 0)
    return run_set_path (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "get_path") == 0 || strcasecmp (cmd, "get-path") == 0)
    return run_get_path (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "set_autosync") == 0 || strcasecmp (cmd, "set-autosync") == 0 || strcasecmp (cmd, "autosync") == 0)
    return run_set_autosync (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "get_autosync") == 0 || strcasecmp (cmd, "get-autosync") == 0)
    return run_get_autosync (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "set_verbose") == 0 || strcasecmp (cmd, "set-verbose") == 0 || strcasecmp (cmd, "verbose") == 0)
    return run_set_verbose (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "get_verbose") == 0 || strcasecmp (cmd, "get-verbose") == 0)
    return run_get_verbose (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "mount") == 0)
    return run_mount (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "sync") == 0)
    return run_sync (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "touch") == 0)
    return run_touch (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "cat") == 0)
    return run_cat (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "ll") == 0)
    return run_ll (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "ls") == 0)
    return run_ls (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "list_devices") == 0 || strcasecmp (cmd, "list-devices") == 0)
    return run_list_devices (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "list_partitions") == 0 || strcasecmp (cmd, "list-partitions") == 0)
    return run_list_partitions (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "pvs") == 0)
    return run_pvs (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "vgs") == 0)
    return run_vgs (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "lvs") == 0)
    return run_lvs (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "pvs_full") == 0 || strcasecmp (cmd, "pvs-full") == 0)
    return run_pvs_full (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "vgs_full") == 0 || strcasecmp (cmd, "vgs-full") == 0)
    return run_vgs_full (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "lvs_full") == 0 || strcasecmp (cmd, "lvs-full") == 0)
    return run_lvs_full (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "read_lines") == 0 || strcasecmp (cmd, "read-lines") == 0)
    return run_read_lines (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_init") == 0 || strcasecmp (cmd, "aug-init") == 0)
    return run_aug_init (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_close") == 0 || strcasecmp (cmd, "aug-close") == 0)
    return run_aug_close (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_defvar") == 0 || strcasecmp (cmd, "aug-defvar") == 0)
    return run_aug_defvar (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_defnode") == 0 || strcasecmp (cmd, "aug-defnode") == 0)
    return run_aug_defnode (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_get") == 0 || strcasecmp (cmd, "aug-get") == 0)
    return run_aug_get (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_set") == 0 || strcasecmp (cmd, "aug-set") == 0)
    return run_aug_set (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_insert") == 0 || strcasecmp (cmd, "aug-insert") == 0)
    return run_aug_insert (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_rm") == 0 || strcasecmp (cmd, "aug-rm") == 0)
    return run_aug_rm (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_mv") == 0 || strcasecmp (cmd, "aug-mv") == 0)
    return run_aug_mv (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_match") == 0 || strcasecmp (cmd, "aug-match") == 0)
    return run_aug_match (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_save") == 0 || strcasecmp (cmd, "aug-save") == 0)
    return run_aug_save (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "aug_load") == 0 || strcasecmp (cmd, "aug-load") == 0)
    return run_aug_load (cmd, argc, argv);
  else
    {
      fprintf (stderr, "%s: unknown command\n", cmd);
      return -1;
    }
  return 0;
}

