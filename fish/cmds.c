/* libguestfs generated file
 * WARNING: THIS FILE IS GENERATED BY 'src/generator.ml'.
 * ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.
 *
 * Copyright (C) 2009 Red Hat Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <inttypes.h>

#include <guestfs.h>
#include "fish.h"

void list_commands (void)
{
  printf ("    %-16s     %s\n", "Command", "Description");
  list_builtin_commands ();
  printf ("%-20s %s\n", "cat", "list the contents of a file");
  printf ("%-20s %s\n", "list-devices", "list the block devices");
  printf ("%-20s %s\n", "list-partitions", "list the partitions");
  printf ("%-20s %s\n", "ll", "list the files in a directory (long format)");
  printf ("%-20s %s\n", "ls", "list the files in a directory");
  printf ("%-20s %s\n", "lvs", "list the LVM logical volumes (LVs)");
  printf ("%-20s %s\n", "lvs-full", "list the LVM logical volumes (LVs)");
  printf ("%-20s %s\n", "mount", "mount a guest disk at a position in the filesystem");
  printf ("%-20s %s\n", "pvs", "list the LVM physical volumes (PVs)");
  printf ("%-20s %s\n", "pvs-full", "list the LVM physical volumes (PVs)");
  printf ("%-20s %s\n", "sync", "sync disks, writes are flushed through to the disk image");
  printf ("%-20s %s\n", "touch", "update file timestamps or create a new file");
  printf ("%-20s %s\n", "vgs", "list the LVM volume groups (VGs)");
  printf ("%-20s %s\n", "vgs-full", "list the LVM volume groups (VGs)");
  printf ("    Use -h <cmd> / help <cmd> to show detailed help for a command.\n");
}

void display_command (const char *cmd)
{
  if (strcasecmp (cmd, "mount") == 0)
    pod2text ("mount - mount a guest disk at a position in the filesystem", " mount <device> <mountpoint>\n\nMount a guest disk at a position in the filesystem.  Block devices\nare named C</dev/sda>, C</dev/sdb> and so on, as they were added to\nthe guest.  If those block devices contain partitions, they will have\nthe usual names (eg. C</dev/sda1>).  Also LVM C</dev/VG/LV>-style\nnames can be used.\n\nThe rules are the same as for L<mount(2)>:  A filesystem must\nfirst be mounted on C</> before others can be mounted.  Other\nfilesystems can only be mounted on directories which already\nexist.\n\nThe mounted filesystem is writable, if we have sufficient permissions\non the underlying device.\n\nThe filesystem options C<sync> and C<noatime> are set with this\ncall, in order to improve reliability.");
  else
  if (strcasecmp (cmd, "sync") == 0)
    pod2text ("sync - sync disks, writes are flushed through to the disk image", " sync\n\nThis syncs the disk, so that any writes are flushed through to the\nunderlying disk image.\n\nYou should always call this if you have modified a disk image, before\ncalling C<guestfs_close>.");
  else
  if (strcasecmp (cmd, "touch") == 0)
    pod2text ("touch - update file timestamps or create a new file", " touch <path>\n\nTouch acts like the L<touch(1)> command.  It can be used to\nupdate the timestamps on a file, or, if the file does not exist,\nto create a new zero-length file.");
  else
  if (strcasecmp (cmd, "cat") == 0)
    pod2text ("cat - list the contents of a file", " cat <path>\n\nReturn the contents of the file named C<path>.\n\nNote that this function cannot correctly handle binary files\n(specifically, files containing C<\\0> character which is treated\nas end of string).  For those you need to use the C<guestfs_read_file>\nfunction which has a more complex interface.\n\nBecause of the message protocol, there is a transfer limit \nof somewhere between 2MB and 4MB.  To transfer large files you should use\nFTP.");
  else
  if (strcasecmp (cmd, "ll") == 0)
    pod2text ("ll - list the files in a directory (long format)", " ll <directory>\n\nList the files in C<directory> (relative to the root directory,\nthere is no cwd) in the format of 'ls -la'.\n\nThis command is mostly useful for interactive sessions.  It\nis I<not> intended that you try to parse the output string.");
  else
  if (strcasecmp (cmd, "ls") == 0)
    pod2text ("ls - list the files in a directory", " ls <directory>\n\nList the files in C<directory> (relative to the root directory,\nthere is no cwd).  The '.' and '..' entries are not returned, but\nhidden files are shown.\n\nThis command is mostly useful for interactive sessions.  Programs\nshould probably use C<guestfs_readdir> instead.");
  else
  if (strcasecmp (cmd, "list_devices") == 0 || strcasecmp (cmd, "list-devices") == 0)
    pod2text ("list-devices - list the block devices", " list-devices\n\nList all the block devices.\n\nThe full block device names are returned, eg. C</dev/sda>\n");
  else
  if (strcasecmp (cmd, "list_partitions") == 0 || strcasecmp (cmd, "list-partitions") == 0)
    pod2text ("list-partitions - list the partitions", " list-partitions\n\nList all the partitions detected on all block devices.\n\nThe full partition device names are returned, eg. C</dev/sda1>\n\nThis does not return logical volumes.  For that you will need to\ncall C<guestfs_lvs>.");
  else
  if (strcasecmp (cmd, "pvs") == 0)
    pod2text ("pvs - list the LVM physical volumes (PVs)", " pvs\n\nList all the physical volumes detected.  This is the equivalent\nof the L<pvs(8)> command.\n\nThis returns a list of just the device names that contain\nPVs (eg. C</dev/sda2>).\n\nSee also C<guestfs_pvs_full>.");
  else
  if (strcasecmp (cmd, "vgs") == 0)
    pod2text ("vgs - list the LVM volume groups (VGs)", " vgs\n\nList all the volumes groups detected.  This is the equivalent\nof the L<vgs(8)> command.\n\nThis returns a list of just the volume group names that were\ndetected (eg. C<VolGroup00>).\n\nSee also C<guestfs_vgs_full>.");
  else
  if (strcasecmp (cmd, "lvs") == 0)
    pod2text ("lvs - list the LVM logical volumes (LVs)", " lvs\n\nList all the logical volumes detected.  This is the equivalent\nof the L<lvs(8)> command.\n\nThis returns a list of the logical volume device names\n(eg. C</dev/VolGroup00/LogVol00>).\n\nSee also C<guestfs_lvs_full>.");
  else
  if (strcasecmp (cmd, "pvs_full") == 0 || strcasecmp (cmd, "pvs-full") == 0)
    pod2text ("pvs-full - list the LVM physical volumes (PVs)", " pvs-full\n\nList all the physical volumes detected.  This is the equivalent\nof the L<pvs(8)> command.  The \"full\" version includes all fields.");
  else
  if (strcasecmp (cmd, "vgs_full") == 0 || strcasecmp (cmd, "vgs-full") == 0)
    pod2text ("vgs-full - list the LVM volume groups (VGs)", " vgs-full\n\nList all the volumes groups detected.  This is the equivalent\nof the L<vgs(8)> command.  The \"full\" version includes all fields.");
  else
  if (strcasecmp (cmd, "lvs_full") == 0 || strcasecmp (cmd, "lvs-full") == 0)
    pod2text ("lvs-full - list the LVM logical volumes (LVs)", " lvs-full\n\nList all the logical volumes detected.  This is the equivalent\nof the L<lvs(8)> command.  The \"full\" version includes all fields.");
  else
    display_builtin_command (cmd);
}

static void print_pv (struct guestfs_lvm_pv *pv)
{
  int i;

  printf ("pv_name: %s\n", pv->pv_name);
  printf ("pv_uuid: ");
  for (i = 0; i < 32; ++i)
    printf ("%c", pv->pv_uuid[i]);
  printf ("\n");
  printf ("pv_fmt: %s\n", pv->pv_fmt);
  printf ("pv_size: %" PRIu64 "\n", pv->pv_size);
  printf ("dev_size: %" PRIu64 "\n", pv->dev_size);
  printf ("pv_free: %" PRIu64 "\n", pv->pv_free);
  printf ("pv_used: %" PRIu64 "\n", pv->pv_used);
  printf ("pv_attr: %s\n", pv->pv_attr);
  printf ("pv_pe_count: %" PRIi64 "\n", pv->pv_pe_count);
  printf ("pv_pe_alloc_count: %" PRIi64 "\n", pv->pv_pe_alloc_count);
  printf ("pv_tags: %s\n", pv->pv_tags);
  printf ("pe_start: %" PRIu64 "\n", pv->pe_start);
  printf ("pv_mda_count: %" PRIi64 "\n", pv->pv_mda_count);
  printf ("pv_mda_free: %" PRIu64 "\n", pv->pv_mda_free);
}

static void print_pv_list (struct guestfs_lvm_pv_list *pvs)
{
  int i;

  for (i = 0; i < pvs->len; ++i)
    print_pv (&pvs->val[i]);
}

static void print_vg (struct guestfs_lvm_vg *vg)
{
  int i;

  printf ("vg_name: %s\n", vg->vg_name);
  printf ("vg_uuid: ");
  for (i = 0; i < 32; ++i)
    printf ("%c", vg->vg_uuid[i]);
  printf ("\n");
  printf ("vg_fmt: %s\n", vg->vg_fmt);
  printf ("vg_attr: %s\n", vg->vg_attr);
  printf ("vg_size: %" PRIu64 "\n", vg->vg_size);
  printf ("vg_free: %" PRIu64 "\n", vg->vg_free);
  printf ("vg_sysid: %s\n", vg->vg_sysid);
  printf ("vg_extent_size: %" PRIu64 "\n", vg->vg_extent_size);
  printf ("vg_extent_count: %" PRIi64 "\n", vg->vg_extent_count);
  printf ("vg_free_count: %" PRIi64 "\n", vg->vg_free_count);
  printf ("max_lv: %" PRIi64 "\n", vg->max_lv);
  printf ("max_pv: %" PRIi64 "\n", vg->max_pv);
  printf ("pv_count: %" PRIi64 "\n", vg->pv_count);
  printf ("lv_count: %" PRIi64 "\n", vg->lv_count);
  printf ("snap_count: %" PRIi64 "\n", vg->snap_count);
  printf ("vg_seqno: %" PRIi64 "\n", vg->vg_seqno);
  printf ("vg_tags: %s\n", vg->vg_tags);
  printf ("vg_mda_count: %" PRIi64 "\n", vg->vg_mda_count);
  printf ("vg_mda_free: %" PRIu64 "\n", vg->vg_mda_free);
}

static void print_vg_list (struct guestfs_lvm_vg_list *vgs)
{
  int i;

  for (i = 0; i < vgs->len; ++i)
    print_vg (&vgs->val[i]);
}

static void print_lv (struct guestfs_lvm_lv *lv)
{
  int i;

  printf ("lv_name: %s\n", lv->lv_name);
  printf ("lv_uuid: ");
  for (i = 0; i < 32; ++i)
    printf ("%c", lv->lv_uuid[i]);
  printf ("\n");
  printf ("lv_attr: %s\n", lv->lv_attr);
  printf ("lv_major: %" PRIi64 "\n", lv->lv_major);
  printf ("lv_minor: %" PRIi64 "\n", lv->lv_minor);
  printf ("lv_kernel_major: %" PRIi64 "\n", lv->lv_kernel_major);
  printf ("lv_kernel_minor: %" PRIi64 "\n", lv->lv_kernel_minor);
  printf ("lv_size: %" PRIu64 "\n", lv->lv_size);
  printf ("seg_count: %" PRIi64 "\n", lv->seg_count);
  printf ("origin: %s\n", lv->origin);
  if (lv->snap_percent >= 0) printf ("snap_percent: %g %%\n", lv->snap_percent);
  else printf ("snap_percent: \n");
  if (lv->copy_percent >= 0) printf ("copy_percent: %g %%\n", lv->copy_percent);
  else printf ("copy_percent: \n");
  printf ("move_pv: %s\n", lv->move_pv);
  printf ("lv_tags: %s\n", lv->lv_tags);
  printf ("mirror_log: %s\n", lv->mirror_log);
  printf ("modules: %s\n", lv->modules);
}

static void print_lv_list (struct guestfs_lvm_lv_list *lvs)
{
  int i;

  for (i = 0; i < lvs->len; ++i)
    print_lv (&lvs->val[i]);
}

static int run_mount (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  const char *mountpoint;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  mountpoint = argv[1];
  r = guestfs_mount (g, device, mountpoint);
  return r;
}

static int run_sync (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_sync (g);
  return r;
}

static int run_touch (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_touch (g, path);
  return r;
}

static int run_cat (const char *cmd, int argc, char *argv[])
{
  char *r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_cat (g, path);
  if (r == NULL) return -1;
  printf ("%s", r);
  free (r);
  return 0;
}

static int run_ll (const char *cmd, int argc, char *argv[])
{
  char *r;
  const char *directory;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  directory = argv[0];
  r = guestfs_ll (g, directory);
  if (r == NULL) return -1;
  printf ("%s", r);
  free (r);
  return 0;
}

static int run_ls (const char *cmd, int argc, char *argv[])
{
  char **r;
  const char *directory;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  directory = argv[0];
  r = guestfs_ls (g, directory);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_list_devices (const char *cmd, int argc, char *argv[])
{
  char **r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_list_devices (g);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_list_partitions (const char *cmd, int argc, char *argv[])
{
  char **r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_list_partitions (g);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_pvs (const char *cmd, int argc, char *argv[])
{
  char **r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_pvs (g);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_vgs (const char *cmd, int argc, char *argv[])
{
  char **r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_vgs (g);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_lvs (const char *cmd, int argc, char *argv[])
{
  char **r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_lvs (g);
  if (r == NULL) return -1;
  print_strings (r);
  free_strings (r);
  return 0;
}

static int run_pvs_full (const char *cmd, int argc, char *argv[])
{
  struct guestfs_lvm_pv_list *r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_pvs_full (g);
  if (r == NULL) return -1;
  print_pv_list (r);
  guestfs_free_lvm_pv_list (r);
  return 0;
}

static int run_vgs_full (const char *cmd, int argc, char *argv[])
{
  struct guestfs_lvm_vg_list *r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_vgs_full (g);
  if (r == NULL) return -1;
  print_vg_list (r);
  guestfs_free_lvm_vg_list (r);
  return 0;
}

static int run_lvs_full (const char *cmd, int argc, char *argv[])
{
  struct guestfs_lvm_lv_list *r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_lvs_full (g);
  if (r == NULL) return -1;
  print_lv_list (r);
  guestfs_free_lvm_lv_list (r);
  return 0;
}

int run_action (const char *cmd, int argc, char *argv[])
{
  if (strcasecmp (cmd, "mount") == 0)
    return run_mount (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "sync") == 0)
    return run_sync (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "touch") == 0)
    return run_touch (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "cat") == 0)
    return run_cat (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "ll") == 0)
    return run_ll (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "ls") == 0)
    return run_ls (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "list_devices") == 0 || strcasecmp (cmd, "list-devices") == 0)
    return run_list_devices (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "list_partitions") == 0 || strcasecmp (cmd, "list-partitions") == 0)
    return run_list_partitions (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "pvs") == 0)
    return run_pvs (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "vgs") == 0)
    return run_vgs (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "lvs") == 0)
    return run_lvs (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "pvs_full") == 0 || strcasecmp (cmd, "pvs-full") == 0)
    return run_pvs_full (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "vgs_full") == 0 || strcasecmp (cmd, "vgs-full") == 0)
    return run_vgs_full (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "lvs_full") == 0 || strcasecmp (cmd, "lvs-full") == 0)
    return run_lvs_full (cmd, argc, argv);
  else
    {
      fprintf (stderr, "%s: unknown command\n", cmd);
      return -1;
    }
  return 0;
}

