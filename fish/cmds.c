/* libguestfs generated file
 * WARNING: THIS FILE IS GENERATED BY 'src/generator.ml'.
 * ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.
 *
 * Copyright (C) 2009 Red Hat Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include "fish.h"

void list_commands (void)
{
  printf ("    %-16s     %s\n", "Command", "Description");
  list_builtin_commands ();
  printf ("%-20s %s\n", "mount", "mount a guest disk at a position in the filesystem");
  printf ("%-20s %s\n", "sync", "sync disks, writes are flushed through to the disk image");
  printf ("%-20s %s\n", "touch", "update file timestamps or create a new file");
  printf ("    Use -h <cmd> / help <cmd> to show detailed help for a command.\n");
}

void display_command (const char *cmd)
{
  if (strcasecmp (cmd, "mount") == 0)
    pod2text ("mount - mount a guest disk at a position in the filesystem", " mount <device> <mountpoint>\n\nMount a guest disk at a position in the filesystem.  Block devices\nare named C</dev/sda>, C</dev/sdb> and so on, as they were added to\nthe guest.  If those block devices contain partitions, they will have\nthe usual names (eg. C</dev/sda1>).  Also LVM C</dev/VG/LV>-style\nnames can be used.\n\nThe rules are the same as for L<mount(2)>:  A filesystem must\nfirst be mounted on C</> before others can be mounted.  Other\nfilesystems can only be mounted on directories which already\nexist.\n\nThe mounted filesystem is writable, if we have sufficient permissions\non the underlying device.\n\nThe filesystem options C<sync> and C<noatime> are set with this\ncall, in order to improve reliability.");
  else
  if (strcasecmp (cmd, "sync") == 0)
    pod2text ("sync - sync disks, writes are flushed through to the disk image", " sync\n\nThis syncs the disk, so that any writes are flushed through to the\nunderlying disk image.\n\nYou should always call this if you have modified a disk image, before\ncalling C<guestfs_close>.");
  else
  if (strcasecmp (cmd, "touch") == 0)
    pod2text ("touch - update file timestamps or create a new file", " touch <path>\n\nTouch acts like the L<touch(1)> command.  It can be used to\nupdate the timestamps on a file, or, if the file does not exist,\nto create a new zero-length file.");
  else
    display_builtin_command (cmd);
}

static int run_mount (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *device;
  const char *mountpoint;
  if (argc != 2) {
    fprintf (stderr, "%s should have 2 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  device = argv[0];
  mountpoint = argv[1];
  r = guestfs_mount (g, device, mountpoint);
  return r;
}

static int run_sync (const char *cmd, int argc, char *argv[])
{
  int r;
  if (argc != 0) {
    fprintf (stderr, "%s should have 0 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  r = guestfs_sync (g);
  return r;
}

static int run_touch (const char *cmd, int argc, char *argv[])
{
  int r;
  const char *path;
  if (argc != 1) {
    fprintf (stderr, "%s should have 1 parameter(s)\n", cmd);
    fprintf (stderr, "type 'help %s' for help on %s\n", cmd, cmd);
    return -1;
  }
  path = argv[0];
  r = guestfs_touch (g, path);
  return r;
}

int run_action (const char *cmd, int argc, char *argv[])
{
  if (strcasecmp (cmd, "mount") == 0)
    return run_mount (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "sync") == 0)
    return run_sync (cmd, argc, argv);
  else
  if (strcasecmp (cmd, "touch") == 0)
    return run_touch (cmd, argc, argv);
  else
    {
      fprintf (stderr, "%s: unknown command\n", cmd);
      return -1;
    }
  return 0;
}

