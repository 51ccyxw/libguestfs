/* libguestfs generated file
 * WARNING: THIS FILE IS GENERATED BY 'src/generator.ml'.
 * ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.
 *
 * Copyright (C) 2009 Red Hat Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

package com.redhat.et.libguestfs;

import java.util.HashMap;
import com.redhat.et.libguestfs.LibGuestFSException;
import com.redhat.et.libguestfs.PV;
import com.redhat.et.libguestfs.VG;
import com.redhat.et.libguestfs.LV;
import com.redhat.et.libguestfs.Stat;
import com.redhat.et.libguestfs.StatVFS;
import com.redhat.et.libguestfs.IntBool;

/**
 * The GuestFS object is a libguestfs handle.
 *
 * @author rjones
 */
public class GuestFS {
  // Load the native code.
  static {
    System.loadLibrary ("guestfs_jni");
  }

  /**
   * The native guestfs_h pointer.
   */
  long g;

  /**
   * Create a libguestfs handle.
   *
   * @throws LibGuestFSException
   */
  public GuestFS () throws LibGuestFSException
  {
    g = _create ();
  }
  private native long _create () throws LibGuestFSException;

  /**
   * Close a libguestfs handle.
   *
   * You can also leave handles to be collected by the garbage
   * collector, but this method ensures that the resources used
   * by the handle are freed up immediately.  If you call any
   * other methods after closing the handle, you will get an
   * exception.
   *
   * @throws LibGuestFSException
   */
  public void close () throws LibGuestFSException
  {
    if (g != 0)
      _close (g);
    g = 0;
  }
  private native void _close (long g) throws LibGuestFSException;

  public void finalize () throws LibGuestFSException
  {
    close ();
  }

  /**
   * launch the qemu subprocess
   *
   * Internally libguestfs is implemented by running a
   * virtual machine using qemu(1).
   * 
   * You should call this after configuring the handle (eg.
   * adding drives) but before performing any actions.
   * 
   * @throws LibGuestFSException
   */
  public void launch ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("launch: handle is closed");
    _launch (g);
  }
  private native void _launch (long g)
    throws LibGuestFSException;

  /**
   * wait until the qemu subprocess launches
   *
   * Internally libguestfs is implemented by running a
   * virtual machine using qemu(1).
   * 
   * You should call this after "g.launch" to wait for the
   * launch to complete.
   * 
   * @throws LibGuestFSException
   */
  public void wait_ready ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("wait_ready: handle is closed");
    _wait_ready (g);
  }
  private native void _wait_ready (long g)
    throws LibGuestFSException;

  /**
   * kill the qemu subprocess
   *
   * This kills the qemu subprocess. You should never need to
   * call this.
   * 
   * @throws LibGuestFSException
   */
  public void kill_subprocess ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("kill_subprocess: handle is closed");
    _kill_subprocess (g);
  }
  private native void _kill_subprocess (long g)
    throws LibGuestFSException;

  /**
   * add an image to examine or modify
   *
   * This function adds a virtual machine disk image
   * "filename" to the guest. The first time you call this
   * function, the disk appears as IDE disk 0 ("/dev/sda") in
   * the guest, the second time as "/dev/sdb", and so on.
   * 
   * You don't necessarily need to be root when using
   * libguestfs. However you obviously do need sufficient
   * permissions to access the filename for whatever
   * operations you want to perform (ie. read access if you
   * just want to read the image or write access if you want
   * to modify the image).
   * 
   * This is equivalent to the qemu parameter "-drive
   * file=filename".
   * 
   * @throws LibGuestFSException
   */
  public void add_drive (String filename)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("add_drive: handle is closed");
    _add_drive (g, filename);
  }
  private native void _add_drive (long g, String filename)
    throws LibGuestFSException;

  /**
   * add a CD-ROM disk image to examine
   *
   * This function adds a virtual CD-ROM disk image to the
   * guest.
   * 
   * This is equivalent to the qemu parameter "-cdrom
   * filename".
   * 
   * @throws LibGuestFSException
   */
  public void add_cdrom (String filename)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("add_cdrom: handle is closed");
    _add_cdrom (g, filename);
  }
  private native void _add_cdrom (long g, String filename)
    throws LibGuestFSException;

  /**
   * add qemu parameters
   *
   * This can be used to add arbitrary qemu command line
   * parameters of the form "-param value". Actually it's not
   * quite arbitrary - we prevent you from setting some
   * parameters which would interfere with parameters that we
   * use.
   * 
   * The first character of "param" string must be a "-"
   * (dash).
   * 
   * "value" can be NULL.
   * 
   * @throws LibGuestFSException
   */
  public void config (String qemuparam, String qemuvalue)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("config: handle is closed");
    _config (g, qemuparam, qemuvalue);
  }
  private native void _config (long g, String qemuparam, String qemuvalue)
    throws LibGuestFSException;

  /**
   * set the qemu binary
   *
   * Set the qemu binary that we will use.
   * 
   * The default is chosen when the library was compiled by
   * the configure script.
   * 
   * You can also override this by setting the
   * "LIBGUESTFS_QEMU" environment variable.
   * 
   * The string "qemu" is stashed in the libguestfs handle,
   * so the caller must make sure it remains valid for the
   * lifetime of the handle.
   * 
   * Setting "qemu" to "NULL" restores the default qemu
   * binary.
   * 
   * @throws LibGuestFSException
   */
  public void set_qemu (String qemu)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_qemu: handle is closed");
    _set_qemu (g, qemu);
  }
  private native void _set_qemu (long g, String qemu)
    throws LibGuestFSException;

  /**
   * get the qemu binary
   *
   * Return the current qemu binary.
   * 
   * This is always non-NULL. If it wasn't set already, then
   * this will return the default qemu binary name.
   * 
   * @throws LibGuestFSException
   */
  public String get_qemu ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("get_qemu: handle is closed");
    return _get_qemu (g);
  }
  private native String _get_qemu (long g)
    throws LibGuestFSException;

  /**
   * set the search path
   *
   * Set the path that libguestfs searches for kernel and
   * initrd.img.
   * 
   * The default is "$libdir/guestfs" unless overridden by
   * setting "LIBGUESTFS_PATH" environment variable.
   * 
   * The string "path" is stashed in the libguestfs handle,
   * so the caller must make sure it remains valid for the
   * lifetime of the handle.
   * 
   * Setting "path" to "NULL" restores the default path.
   * 
   * @throws LibGuestFSException
   */
  public void set_path (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_path: handle is closed");
    _set_path (g, path);
  }
  private native void _set_path (long g, String path)
    throws LibGuestFSException;

  /**
   * get the search path
   *
   * Return the current search path.
   * 
   * This is always non-NULL. If it wasn't set already, then
   * this will return the default path.
   * 
   * @throws LibGuestFSException
   */
  public String get_path ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("get_path: handle is closed");
    return _get_path (g);
  }
  private native String _get_path (long g)
    throws LibGuestFSException;

  /**
   * set autosync mode
   *
   * If "autosync" is true, this enables autosync. Libguestfs
   * will make a best effort attempt to run "g.sync" when the
   * handle is closed (also if the program exits without
   * closing handles).
   * 
   * @throws LibGuestFSException
   */
  public void set_autosync (boolean autosync)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_autosync: handle is closed");
    _set_autosync (g, autosync);
  }
  private native void _set_autosync (long g, boolean autosync)
    throws LibGuestFSException;

  /**
   * get autosync mode
   *
   * Get the autosync flag.
   * 
   * @throws LibGuestFSException
   */
  public boolean get_autosync ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("get_autosync: handle is closed");
    return _get_autosync (g);
  }
  private native boolean _get_autosync (long g)
    throws LibGuestFSException;

  /**
   * set verbose mode
   *
   * If "verbose" is true, this turns on verbose messages (to
   * "stderr").
   * 
   * Verbose messages are disabled unless the environment
   * variable "LIBGUESTFS_DEBUG" is defined and set to 1.
   * 
   * @throws LibGuestFSException
   */
  public void set_verbose (boolean verbose)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_verbose: handle is closed");
    _set_verbose (g, verbose);
  }
  private native void _set_verbose (long g, boolean verbose)
    throws LibGuestFSException;

  /**
   * get verbose mode
   *
   * This returns the verbose messages flag.
   * 
   * @throws LibGuestFSException
   */
  public boolean get_verbose ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("get_verbose: handle is closed");
    return _get_verbose (g);
  }
  private native boolean _get_verbose (long g)
    throws LibGuestFSException;

  /**
   * is ready to accept commands
   *
   * This returns true iff this handle is ready to accept
   * commands (in the "READY" state).
   * 
   * For more information on states, see guestfs(3).
   * 
   * @throws LibGuestFSException
   */
  public boolean is_ready ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("is_ready: handle is closed");
    return _is_ready (g);
  }
  private native boolean _is_ready (long g)
    throws LibGuestFSException;

  /**
   * is in configuration state
   *
   * This returns true iff this handle is being configured
   * (in the "CONFIG" state).
   * 
   * For more information on states, see guestfs(3).
   * 
   * @throws LibGuestFSException
   */
  public boolean is_config ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("is_config: handle is closed");
    return _is_config (g);
  }
  private native boolean _is_config (long g)
    throws LibGuestFSException;

  /**
   * is launching subprocess
   *
   * This returns true iff this handle is launching the
   * subprocess (in the "LAUNCHING" state).
   * 
   * For more information on states, see guestfs(3).
   * 
   * @throws LibGuestFSException
   */
  public boolean is_launching ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("is_launching: handle is closed");
    return _is_launching (g);
  }
  private native boolean _is_launching (long g)
    throws LibGuestFSException;

  /**
   * is busy processing a command
   *
   * This returns true iff this handle is busy processing a
   * command (in the "BUSY" state).
   * 
   * For more information on states, see guestfs(3).
   * 
   * @throws LibGuestFSException
   */
  public boolean is_busy ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("is_busy: handle is closed");
    return _is_busy (g);
  }
  private native boolean _is_busy (long g)
    throws LibGuestFSException;

  /**
   * get the current state
   *
   * This returns the current state as an opaque integer.
   * This is only useful for printing debug and internal
   * error messages.
   * 
   * For more information on states, see guestfs(3).
   * 
   * @throws LibGuestFSException
   */
  public int get_state ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("get_state: handle is closed");
    return _get_state (g);
  }
  private native int _get_state (long g)
    throws LibGuestFSException;

  /**
   * set state to busy
   *
   * This sets the state to "BUSY". This is only used when
   * implementing actions using the low-level API.
   * 
   * For more information on states, see guestfs(3).
   * 
   * @throws LibGuestFSException
   */
  public void set_busy ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_busy: handle is closed");
    _set_busy (g);
  }
  private native void _set_busy (long g)
    throws LibGuestFSException;

  /**
   * set state to ready
   *
   * This sets the state to "READY". This is only used when
   * implementing actions using the low-level API.
   * 
   * For more information on states, see guestfs(3).
   * 
   * @throws LibGuestFSException
   */
  public void set_ready ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_ready: handle is closed");
    _set_ready (g);
  }
  private native void _set_ready (long g)
    throws LibGuestFSException;

  /**
   * mount a guest disk at a position in the filesystem
   *
   * Mount a guest disk at a position in the filesystem.
   * Block devices are named "/dev/sda", "/dev/sdb" and so
   * on, as they were added to the guest. If those block
   * devices contain partitions, they will have the usual
   * names (eg. "/dev/sda1"). Also LVM "/dev/VG/LV"-style
   * names can be used.
   * 
   * The rules are the same as for mount(2): A filesystem
   * must first be mounted on "/" before others can be
   * mounted. Other filesystems can only be mounted on
   * directories which already exist.
   * 
   * The mounted filesystem is writable, if we have
   * sufficient permissions on the underlying device.
   * 
   * The filesystem options "sync" and "noatime" are set with
   * this call, in order to improve reliability.
   * 
   * @throws LibGuestFSException
   */
  public void mount (String device, String mountpoint)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mount: handle is closed");
    _mount (g, device, mountpoint);
  }
  private native void _mount (long g, String device, String mountpoint)
    throws LibGuestFSException;

  /**
   * sync disks, writes are flushed through to the disk image
   *
   * This syncs the disk, so that any writes are flushed
   * through to the underlying disk image.
   * 
   * You should always call this if you have modified a disk
   * image, before closing the handle.
   * 
   * @throws LibGuestFSException
   */
  public void sync ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("sync: handle is closed");
    _sync (g);
  }
  private native void _sync (long g)
    throws LibGuestFSException;

  /**
   * update file timestamps or create a new file
   *
   * Touch acts like the touch(1) command. It can be used to
   * update the timestamps on a file, or, if the file does
   * not exist, to create a new zero-length file.
   * 
   * @throws LibGuestFSException
   */
  public void touch (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("touch: handle is closed");
    _touch (g, path);
  }
  private native void _touch (long g, String path)
    throws LibGuestFSException;

  /**
   * list the contents of a file
   *
   * Return the contents of the file named "path".
   * 
   * Note that this function cannot correctly handle binary
   * files (specifically, files containing "\0" character
   * which is treated as end of string). For those you need
   * to use the "g.download" function which has a more
   * complex interface.
   * 
   * Because of the message protocol, there is a transfer
   * limit of somewhere between 2MB and 4MB. To transfer
   * large files you should use FTP.
   * 
   * @throws LibGuestFSException
   */
  public String cat (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("cat: handle is closed");
    return _cat (g, path);
  }
  private native String _cat (long g, String path)
    throws LibGuestFSException;

  /**
   * list the files in a directory (long format)
   *
   * List the files in "directory" (relative to the root
   * directory, there is no cwd) in the format of 'ls -la'.
   * 
   * This command is mostly useful for interactive sessions.
   * It is *not* intended that you try to parse the output
   * string.
   * 
   * @throws LibGuestFSException
   */
  public String ll (String directory)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("ll: handle is closed");
    return _ll (g, directory);
  }
  private native String _ll (long g, String directory)
    throws LibGuestFSException;

  /**
   * list the files in a directory
   *
   * List the files in "directory" (relative to the root
   * directory, there is no cwd). The '.' and '..' entries
   * are not returned, but hidden files are shown.
   * 
   * This command is mostly useful for interactive sessions.
   * Programs should probably use "g.readdir" instead.
   * 
   * @throws LibGuestFSException
   */
  public String[] ls (String directory)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("ls: handle is closed");
    return _ls (g, directory);
  }
  private native String[] _ls (long g, String directory)
    throws LibGuestFSException;

  /**
   * list the block devices
   *
   * List all the block devices.
   * 
   * The full block device names are returned, eg. "/dev/sda"
   * 
   * @throws LibGuestFSException
   */
  public String[] list_devices ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("list_devices: handle is closed");
    return _list_devices (g);
  }
  private native String[] _list_devices (long g)
    throws LibGuestFSException;

  /**
   * list the partitions
   *
   * List all the partitions detected on all block devices.
   * 
   * The full partition device names are returned, eg.
   * "/dev/sda1"
   * 
   * This does not return logical volumes. For that you will
   * need to call "g.lvs".
   * 
   * @throws LibGuestFSException
   */
  public String[] list_partitions ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("list_partitions: handle is closed");
    return _list_partitions (g);
  }
  private native String[] _list_partitions (long g)
    throws LibGuestFSException;

  /**
   * list the LVM physical volumes (PVs)
   *
   * List all the physical volumes detected. This is the
   * equivalent of the pvs(8) command.
   * 
   * This returns a list of just the device names that
   * contain PVs (eg. "/dev/sda2").
   * 
   * See also "g.pvs_full".
   * 
   * @throws LibGuestFSException
   */
  public String[] pvs ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("pvs: handle is closed");
    return _pvs (g);
  }
  private native String[] _pvs (long g)
    throws LibGuestFSException;

  /**
   * list the LVM volume groups (VGs)
   *
   * List all the volumes groups detected. This is the
   * equivalent of the vgs(8) command.
   * 
   * This returns a list of just the volume group names that
   * were detected (eg. "VolGroup00").
   * 
   * See also "g.vgs_full".
   * 
   * @throws LibGuestFSException
   */
  public String[] vgs ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("vgs: handle is closed");
    return _vgs (g);
  }
  private native String[] _vgs (long g)
    throws LibGuestFSException;

  /**
   * list the LVM logical volumes (LVs)
   *
   * List all the logical volumes detected. This is the
   * equivalent of the lvs(8) command.
   * 
   * This returns a list of the logical volume device names
   * (eg. "/dev/VolGroup00/LogVol00").
   * 
   * See also "g.lvs_full".
   * 
   * @throws LibGuestFSException
   */
  public String[] lvs ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("lvs: handle is closed");
    return _lvs (g);
  }
  private native String[] _lvs (long g)
    throws LibGuestFSException;

  /**
   * list the LVM physical volumes (PVs)
   *
   * List all the physical volumes detected. This is the
   * equivalent of the pvs(8) command. The "full" version
   * includes all fields.
   * 
   * @throws LibGuestFSException
   */
  public PV[] pvs_full ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("pvs_full: handle is closed");
    return _pvs_full (g);
  }
  private native PV[] _pvs_full (long g)
    throws LibGuestFSException;

  /**
   * list the LVM volume groups (VGs)
   *
   * List all the volumes groups detected. This is the
   * equivalent of the vgs(8) command. The "full" version
   * includes all fields.
   * 
   * @throws LibGuestFSException
   */
  public VG[] vgs_full ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("vgs_full: handle is closed");
    return _vgs_full (g);
  }
  private native VG[] _vgs_full (long g)
    throws LibGuestFSException;

  /**
   * list the LVM logical volumes (LVs)
   *
   * List all the logical volumes detected. This is the
   * equivalent of the lvs(8) command. The "full" version
   * includes all fields.
   * 
   * @throws LibGuestFSException
   */
  public LV[] lvs_full ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("lvs_full: handle is closed");
    return _lvs_full (g);
  }
  private native LV[] _lvs_full (long g)
    throws LibGuestFSException;

  /**
   * read file as lines
   *
   * Return the contents of the file named "path".
   * 
   * The file contents are returned as a list of lines.
   * Trailing "LF" and "CRLF" character sequences are *not*
   * returned.
   * 
   * Note that this function cannot correctly handle binary
   * files (specifically, files containing "\0" character
   * which is treated as end of line). For those you need to
   * use the "g.read_file" function which has a more complex
   * interface.
   * 
   * @throws LibGuestFSException
   */
  public String[] read_lines (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("read_lines: handle is closed");
    return _read_lines (g, path);
  }
  private native String[] _read_lines (long g, String path)
    throws LibGuestFSException;

  /**
   * create a new Augeas handle
   *
   * Create a new Augeas handle for editing configuration
   * files. If there was any previous Augeas handle
   * associated with this guestfs session, then it is closed.
   * 
   * You must call this before using any other "g.aug_*"
   * commands.
   * 
   * "root" is the filesystem root. "root" must not be NULL,
   * use "/" instead.
   * 
   * The flags are the same as the flags defined in
   * <augeas.h>, the logical *or* of the following integers:
   * 
   * "AUG_SAVE_BACKUP" = 1
   * Keep the original file with a ".augsave" extension.
   * 
   * "AUG_SAVE_NEWFILE" = 2
   * Save changes into a file with extension ".augnew",
   * and do not overwrite original. Overrides
   * "AUG_SAVE_BACKUP".
   * 
   * "AUG_TYPE_CHECK" = 4
   * Typecheck lenses (can be expensive).
   * 
   * "AUG_NO_STDINC" = 8
   * Do not use standard load path for modules.
   * 
   * "AUG_SAVE_NOOP" = 16
   * Make save a no-op, just record what would have been
   * changed.
   * 
   * "AUG_NO_LOAD" = 32
   * Do not load the tree in "g.aug_init".
   * 
   * To close the handle, you can call "g.aug_close".
   * 
   * To find out more about Augeas, see <http://augeas.net/>.
   * 
   * @throws LibGuestFSException
   */
  public void aug_init (String root, int flags)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_init: handle is closed");
    _aug_init (g, root, flags);
  }
  private native void _aug_init (long g, String root, int flags)
    throws LibGuestFSException;

  /**
   * close the current Augeas handle
   *
   * Close the current Augeas handle and free up any
   * resources used by it. After calling this, you have to
   * call "g.aug_init" again before you can use any other
   * Augeas functions.
   * 
   * @throws LibGuestFSException
   */
  public void aug_close ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_close: handle is closed");
    _aug_close (g);
  }
  private native void _aug_close (long g)
    throws LibGuestFSException;

  /**
   * define an Augeas variable
   *
   * Defines an Augeas variable "name" whose value is the
   * result of evaluating "expr". If "expr" is NULL, then
   * "name" is undefined.
   * 
   * On success this returns the number of nodes in "expr",
   * or 0 if "expr" evaluates to something which is not a
   * nodeset.
   * 
   * @throws LibGuestFSException
   */
  public int aug_defvar (String name, String expr)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_defvar: handle is closed");
    return _aug_defvar (g, name, expr);
  }
  private native int _aug_defvar (long g, String name, String expr)
    throws LibGuestFSException;

  /**
   * define an Augeas node
   *
   * Defines a variable "name" whose value is the result of
   * evaluating "expr".
   * 
   * If "expr" evaluates to an empty nodeset, a node is
   * created, equivalent to calling "g.aug_set" "expr",
   * "value". "name" will be the nodeset containing that
   * single node.
   * 
   * On success this returns a pair containing the number of
   * nodes in the nodeset, and a boolean flag if a node was
   * created.
   * 
   * @throws LibGuestFSException
   */
  public IntBool aug_defnode (String name, String expr, String val)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_defnode: handle is closed");
    return _aug_defnode (g, name, expr, val);
  }
  private native IntBool _aug_defnode (long g, String name, String expr, String val)
    throws LibGuestFSException;

  /**
   * look up the value of an Augeas path
   *
   * Look up the value associated with "path". If "path"
   * matches exactly one node, the "value" is returned.
   * 
   * @throws LibGuestFSException
   */
  public String aug_get (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_get: handle is closed");
    return _aug_get (g, path);
  }
  private native String _aug_get (long g, String path)
    throws LibGuestFSException;

  /**
   * set Augeas path to value
   *
   * Set the value associated with "path" to "value".
   * 
   * @throws LibGuestFSException
   */
  public void aug_set (String path, String val)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_set: handle is closed");
    _aug_set (g, path, val);
  }
  private native void _aug_set (long g, String path, String val)
    throws LibGuestFSException;

  /**
   * insert a sibling Augeas node
   *
   * Create a new sibling "label" for "path", inserting it
   * into the tree before or after "path" (depending on the
   * boolean flag "before").
   * 
   * "path" must match exactly one existing node in the tree,
   * and "label" must be a label, ie. not contain "/", "*" or
   * end with a bracketed index "[N]".
   * 
   * @throws LibGuestFSException
   */
  public void aug_insert (String path, String label, boolean before)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_insert: handle is closed");
    _aug_insert (g, path, label, before);
  }
  private native void _aug_insert (long g, String path, String label, boolean before)
    throws LibGuestFSException;

  /**
   * remove an Augeas path
   *
   * Remove "path" and all of its children.
   * 
   * On success this returns the number of entries which were
   * removed.
   * 
   * @throws LibGuestFSException
   */
  public int aug_rm (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_rm: handle is closed");
    return _aug_rm (g, path);
  }
  private native int _aug_rm (long g, String path)
    throws LibGuestFSException;

  /**
   * move Augeas node
   *
   * Move the node "src" to "dest". "src" must match exactly
   * one node. "dest" is overwritten if it exists.
   * 
   * @throws LibGuestFSException
   */
  public void aug_mv (String src, String dest)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_mv: handle is closed");
    _aug_mv (g, src, dest);
  }
  private native void _aug_mv (long g, String src, String dest)
    throws LibGuestFSException;

  /**
   * return Augeas nodes which match path
   *
   * Returns a list of paths which match the path expression
   * "path". The returned paths are sufficiently qualified so
   * that they match exactly one node in the current tree.
   * 
   * @throws LibGuestFSException
   */
  public String[] aug_match (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_match: handle is closed");
    return _aug_match (g, path);
  }
  private native String[] _aug_match (long g, String path)
    throws LibGuestFSException;

  /**
   * write all pending Augeas changes to disk
   *
   * This writes all pending changes to disk.
   * 
   * The flags which were passed to "g.aug_init" affect
   * exactly how files are saved.
   * 
   * @throws LibGuestFSException
   */
  public void aug_save ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_save: handle is closed");
    _aug_save (g);
  }
  private native void _aug_save (long g)
    throws LibGuestFSException;

  /**
   * load files into the tree
   *
   * Load files into the tree.
   * 
   * See "aug_load" in the Augeas documentation for the full
   * gory details.
   * 
   * @throws LibGuestFSException
   */
  public void aug_load ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_load: handle is closed");
    _aug_load (g);
  }
  private native void _aug_load (long g)
    throws LibGuestFSException;

  /**
   * list Augeas nodes under a path
   *
   * This is just a shortcut for listing "g.aug_match"
   * "path/*" and sorting the resulting nodes into
   * alphabetical order.
   * 
   * @throws LibGuestFSException
   */
  public String[] aug_ls (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("aug_ls: handle is closed");
    return _aug_ls (g, path);
  }
  private native String[] _aug_ls (long g, String path)
    throws LibGuestFSException;

  /**
   * remove a file
   *
   * Remove the single file "path".
   * 
   * @throws LibGuestFSException
   */
  public void rm (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("rm: handle is closed");
    _rm (g, path);
  }
  private native void _rm (long g, String path)
    throws LibGuestFSException;

  /**
   * remove a directory
   *
   * Remove the single directory "path".
   * 
   * @throws LibGuestFSException
   */
  public void rmdir (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("rmdir: handle is closed");
    _rmdir (g, path);
  }
  private native void _rmdir (long g, String path)
    throws LibGuestFSException;

  /**
   * remove a file or directory recursively
   *
   * Remove the file or directory "path", recursively
   * removing the contents if its a directory. This is like
   * the "rm -rf" shell command.
   * 
   * @throws LibGuestFSException
   */
  public void rm_rf (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("rm_rf: handle is closed");
    _rm_rf (g, path);
  }
  private native void _rm_rf (long g, String path)
    throws LibGuestFSException;

  /**
   * create a directory
   *
   * Create a directory named "path".
   * 
   * @throws LibGuestFSException
   */
  public void mkdir (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mkdir: handle is closed");
    _mkdir (g, path);
  }
  private native void _mkdir (long g, String path)
    throws LibGuestFSException;

  /**
   * create a directory and parents
   *
   * Create a directory named "path", creating any parent
   * directories as necessary. This is like the "mkdir -p"
   * shell command.
   * 
   * @throws LibGuestFSException
   */
  public void mkdir_p (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mkdir_p: handle is closed");
    _mkdir_p (g, path);
  }
  private native void _mkdir_p (long g, String path)
    throws LibGuestFSException;

  /**
   * change file mode
   *
   * Change the mode (permissions) of "path" to "mode". Only
   * numeric modes are supported.
   * 
   * @throws LibGuestFSException
   */
  public void chmod (int mode, String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("chmod: handle is closed");
    _chmod (g, mode, path);
  }
  private native void _chmod (long g, int mode, String path)
    throws LibGuestFSException;

  /**
   * change file owner and group
   *
   * Change the file owner to "owner" and group to "group".
   * 
   * Only numeric uid and gid are supported. If you want to
   * use names, you will need to locate and parse the
   * password file yourself (Augeas support makes this
   * relatively easy).
   * 
   * @throws LibGuestFSException
   */
  public void chown (int owner, int group, String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("chown: handle is closed");
    _chown (g, owner, group, path);
  }
  private native void _chown (long g, int owner, int group, String path)
    throws LibGuestFSException;

  /**
   * test if file or directory exists
   *
   * This returns "true" if and only if there is a file,
   * directory (or anything) with the given "path" name.
   * 
   * See also "g.is_file", "g.is_dir", "g.stat".
   * 
   * @throws LibGuestFSException
   */
  public boolean exists (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("exists: handle is closed");
    return _exists (g, path);
  }
  private native boolean _exists (long g, String path)
    throws LibGuestFSException;

  /**
   * test if file exists
   *
   * This returns "true" if and only if there is a file with
   * the given "path" name. Note that it returns false for
   * other objects like directories.
   * 
   * See also "g.stat".
   * 
   * @throws LibGuestFSException
   */
  public boolean is_file (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("is_file: handle is closed");
    return _is_file (g, path);
  }
  private native boolean _is_file (long g, String path)
    throws LibGuestFSException;

  /**
   * test if file exists
   *
   * This returns "true" if and only if there is a directory
   * with the given "path" name. Note that it returns false
   * for other objects like files.
   * 
   * See also "g.stat".
   * 
   * @throws LibGuestFSException
   */
  public boolean is_dir (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("is_dir: handle is closed");
    return _is_dir (g, path);
  }
  private native boolean _is_dir (long g, String path)
    throws LibGuestFSException;

  /**
   * create an LVM physical volume
   *
   * This creates an LVM physical volume on the named
   * "device", where "device" should usually be a partition
   * name such as "/dev/sda1".
   * 
   * @throws LibGuestFSException
   */
  public void pvcreate (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("pvcreate: handle is closed");
    _pvcreate (g, device);
  }
  private native void _pvcreate (long g, String device)
    throws LibGuestFSException;

  /**
   * create an LVM volume group
   *
   * This creates an LVM volume group called "volgroup" from
   * the non-empty list of physical volumes "physvols".
   * 
   * @throws LibGuestFSException
   */
  public void vgcreate (String volgroup, String[] physvols)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("vgcreate: handle is closed");
    _vgcreate (g, volgroup, physvols);
  }
  private native void _vgcreate (long g, String volgroup, String[] physvols)
    throws LibGuestFSException;

  /**
   * create an LVM volume group
   *
   * This creates an LVM volume group called "logvol" on the
   * volume group "volgroup", with "size" megabytes.
   * 
   * @throws LibGuestFSException
   */
  public void lvcreate (String logvol, String volgroup, int mbytes)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("lvcreate: handle is closed");
    _lvcreate (g, logvol, volgroup, mbytes);
  }
  private native void _lvcreate (long g, String logvol, String volgroup, int mbytes)
    throws LibGuestFSException;

  /**
   * make a filesystem
   *
   * This creates a filesystem on "device" (usually a
   * partition of LVM logical volume). The filesystem type is
   * "fstype", for example "ext3".
   * 
   * @throws LibGuestFSException
   */
  public void mkfs (String fstype, String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mkfs: handle is closed");
    _mkfs (g, fstype, device);
  }
  private native void _mkfs (long g, String fstype, String device)
    throws LibGuestFSException;

  /**
   * create partitions on a block device
   *
   * This is a direct interface to the sfdisk(8) program for
   * creating partitions on block devices.
   * 
   * "device" should be a block device, for example
   * "/dev/sda".
   * 
   * "cyls", "heads" and "sectors" are the number of
   * cylinders, heads and sectors on the device, which are
   * passed directly to sfdisk as the *-C*, *-H* and *-S*
   * parameters. If you pass 0 for any of these, then the
   * corresponding parameter is omitted. Usually for 'large'
   * disks, you can just pass 0 for these, but for small
   * (floppy-sized) disks, sfdisk (or rather, the kernel)
   * cannot work out the right geometry and you will need to
   * tell it.
   * 
   * "lines" is a list of lines that we feed to "sfdisk". For
   * more information refer to the sfdisk(8) manpage.
   * 
   * To create a single partition occupying the whole disk,
   * you would pass "lines" as a single element list, when
   * the single element being the string "," (comma).
   * 
   * This command is dangerous. Without careful use you can
   * easily destroy all your data.
   * 
   * @throws LibGuestFSException
   */
  public void sfdisk (String device, int cyls, int heads, int sectors, String[] lines)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("sfdisk: handle is closed");
    _sfdisk (g, device, cyls, heads, sectors, lines);
  }
  private native void _sfdisk (long g, String device, int cyls, int heads, int sectors, String[] lines)
    throws LibGuestFSException;

  /**
   * create a file
   *
   * This call creates a file called "path". The contents of
   * the file is the string "content" (which can contain any
   * 8 bit data), with length "size".
   * 
   * As a special case, if "size" is 0 then the length is
   * calculated using "strlen" (so in this case the content
   * cannot contain embedded ASCII NULs).
   * 
   * Because of the message protocol, there is a transfer
   * limit of somewhere between 2MB and 4MB. To transfer
   * large files you should use FTP.
   * 
   * @throws LibGuestFSException
   */
  public void write_file (String path, String content, int size)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("write_file: handle is closed");
    _write_file (g, path, content, size);
  }
  private native void _write_file (long g, String path, String content, int size)
    throws LibGuestFSException;

  /**
   * unmount a filesystem
   *
   * This unmounts the given filesystem. The filesystem may
   * be specified either by its mountpoint (path) or the
   * device which contains the filesystem.
   * 
   * @throws LibGuestFSException
   */
  public void umount (String pathordevice)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("umount: handle is closed");
    _umount (g, pathordevice);
  }
  private native void _umount (long g, String pathordevice)
    throws LibGuestFSException;

  /**
   * show mounted filesystems
   *
   * This returns the list of currently mounted filesystems.
   * It returns the list of devices (eg. "/dev/sda1",
   * "/dev/VG/LV").
   * 
   * Some internal mounts are not shown.
   * 
   * @throws LibGuestFSException
   */
  public String[] mounts ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mounts: handle is closed");
    return _mounts (g);
  }
  private native String[] _mounts (long g)
    throws LibGuestFSException;

  /**
   * unmount all filesystems
   *
   * This unmounts all mounted filesystems.
   * 
   * Some internal mounts are not unmounted by this call.
   * 
   * @throws LibGuestFSException
   */
  public void umount_all ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("umount_all: handle is closed");
    _umount_all (g);
  }
  private native void _umount_all (long g)
    throws LibGuestFSException;

  /**
   * remove all LVM LVs, VGs and PVs
   *
   * This command removes all LVM logical volumes, volume
   * groups and physical volumes.
   * 
   * This command is dangerous. Without careful use you can
   * easily destroy all your data.
   * 
   * @throws LibGuestFSException
   */
  public void lvm_remove_all ()
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("lvm_remove_all: handle is closed");
    _lvm_remove_all (g);
  }
  private native void _lvm_remove_all (long g)
    throws LibGuestFSException;

  /**
   * determine file type
   *
   * This call uses the standard file(1) command to determine
   * the type or contents of the file. This also works on
   * devices, for example to find out whether a partition
   * contains a filesystem.
   * 
   * The exact command which runs is "file -bsL path". Note
   * in particular that the filename is not prepended to the
   * output (the "-b" option).
   * 
   * @throws LibGuestFSException
   */
  public String file (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("file: handle is closed");
    return _file (g, path);
  }
  private native String _file (long g, String path)
    throws LibGuestFSException;

  /**
   * run a command from the guest filesystem
   *
   * This call runs a command from the guest filesystem. The
   * filesystem must be mounted, and must contain a
   * compatible operating system (ie. something Linux, with
   * the same or compatible processor architecture).
   * 
   * The single parameter is an argv-style list of arguments.
   * The first element is the name of the program to run.
   * Subsequent elements are parameters. The list must be
   * non-empty (ie. must contain a program name).
   * 
   * The $PATH environment variable will contain at least
   * "/usr/bin" and "/bin". If you require a program from
   * another location, you should provide the full path in
   * the first parameter.
   * 
   * Shared libraries and data files required by the program
   * must be available on filesystems which are mounted in
   * the correct places. It is the caller's responsibility to
   * ensure all filesystems that are needed are mounted at
   * the right locations.
   * 
   * @throws LibGuestFSException
   */
  public String command (String[] arguments)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("command: handle is closed");
    return _command (g, arguments);
  }
  private native String _command (long g, String[] arguments)
    throws LibGuestFSException;

  /**
   * run a command, returning lines
   *
   * This is the same as "g.command", but splits the result
   * into a list of lines.
   * 
   * @throws LibGuestFSException
   */
  public String[] command_lines (String[] arguments)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("command_lines: handle is closed");
    return _command_lines (g, arguments);
  }
  private native String[] _command_lines (long g, String[] arguments)
    throws LibGuestFSException;

  /**
   * get file information
   *
   * Returns file information for the given "path".
   * 
   * This is the same as the stat(2) system call.
   * 
   * @throws LibGuestFSException
   */
  public Stat stat (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("stat: handle is closed");
    return _stat (g, path);
  }
  private native Stat _stat (long g, String path)
    throws LibGuestFSException;

  /**
   * get file information for a symbolic link
   *
   * Returns file information for the given "path".
   * 
   * This is the same as "g.stat" except that if "path" is a
   * symbolic link, then the link is stat-ed, not the file it
   * refers to.
   * 
   * This is the same as the lstat(2) system call.
   * 
   * @throws LibGuestFSException
   */
  public Stat lstat (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("lstat: handle is closed");
    return _lstat (g, path);
  }
  private native Stat _lstat (long g, String path)
    throws LibGuestFSException;

  /**
   * get file system statistics
   *
   * Returns file system statistics for any mounted file
   * system. "path" should be a file or directory in the
   * mounted file system (typically it is the mount point
   * itself, but it doesn't need to be).
   * 
   * This is the same as the statvfs(2) system call.
   * 
   * @throws LibGuestFSException
   */
  public StatVFS statvfs (String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("statvfs: handle is closed");
    return _statvfs (g, path);
  }
  private native StatVFS _statvfs (long g, String path)
    throws LibGuestFSException;

  /**
   * get ext2/ext3/ext4 superblock details
   *
   * This returns the contents of the ext2, ext3 or ext4
   * filesystem superblock on "device".
   * 
   * It is the same as running "tune2fs -l device". See
   * tune2fs(8) manpage for more details. The list of fields
   * returned isn't clearly defined, and depends on both the
   * version of "tune2fs" that libguestfs was built against,
   * and the filesystem itself.
   * 
   * @throws LibGuestFSException
   */
  public HashMap<String,String> tune2fs_l (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("tune2fs_l: handle is closed");
    return _tune2fs_l (g, device);
  }
  private native HashMap<String,String> _tune2fs_l (long g, String device)
    throws LibGuestFSException;

  /**
   * set block device to read-only
   *
   * Sets the block device named "device" to read-only.
   * 
   * This uses the blockdev(8) command.
   * 
   * @throws LibGuestFSException
   */
  public void blockdev_setro (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_setro: handle is closed");
    _blockdev_setro (g, device);
  }
  private native void _blockdev_setro (long g, String device)
    throws LibGuestFSException;

  /**
   * set block device to read-write
   *
   * Sets the block device named "device" to read-write.
   * 
   * This uses the blockdev(8) command.
   * 
   * @throws LibGuestFSException
   */
  public void blockdev_setrw (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_setrw: handle is closed");
    _blockdev_setrw (g, device);
  }
  private native void _blockdev_setrw (long g, String device)
    throws LibGuestFSException;

  /**
   * is block device set to read-only
   *
   * Returns a boolean indicating if the block device is
   * read-only (true if read-only, false if not).
   * 
   * This uses the blockdev(8) command.
   * 
   * @throws LibGuestFSException
   */
  public boolean blockdev_getro (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_getro: handle is closed");
    return _blockdev_getro (g, device);
  }
  private native boolean _blockdev_getro (long g, String device)
    throws LibGuestFSException;

  /**
   * get sectorsize of block device
   *
   * This returns the size of sectors on a block device.
   * Usually 512, but can be larger for modern devices.
   * 
   * (Note, this is not the size in sectors, use
   * "g.blockdev_getsz" for that).
   * 
   * This uses the blockdev(8) command.
   * 
   * @throws LibGuestFSException
   */
  public int blockdev_getss (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_getss: handle is closed");
    return _blockdev_getss (g, device);
  }
  private native int _blockdev_getss (long g, String device)
    throws LibGuestFSException;

  /**
   * get blocksize of block device
   *
   * This returns the block size of a device.
   * 
   * (Note this is different from both *size in blocks* and
   * *filesystem block size*).
   * 
   * This uses the blockdev(8) command.
   * 
   * @throws LibGuestFSException
   */
  public int blockdev_getbsz (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_getbsz: handle is closed");
    return _blockdev_getbsz (g, device);
  }
  private native int _blockdev_getbsz (long g, String device)
    throws LibGuestFSException;

  /**
   * set blocksize of block device
   *
   * This sets the block size of a device.
   * 
   * (Note this is different from both *size in blocks* and
   * *filesystem block size*).
   * 
   * This uses the blockdev(8) command.
   * 
   * @throws LibGuestFSException
   */
  public void blockdev_setbsz (String device, int blocksize)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_setbsz: handle is closed");
    _blockdev_setbsz (g, device, blocksize);
  }
  private native void _blockdev_setbsz (long g, String device, int blocksize)
    throws LibGuestFSException;

  /**
   * get total size of device in 512-byte sectors
   *
   * This returns the size of the device in units of 512-byte
   * sectors (even if the sectorsize isn't 512 bytes ...
   * weird).
   * 
   * See also "g.blockdev_getss" for the real sector size of
   * the device, and "g.blockdev_getsize64" for the more
   * useful *size in bytes*.
   * 
   * This uses the blockdev(8) command.
   * 
   * @throws LibGuestFSException
   */
  public long blockdev_getsz (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_getsz: handle is closed");
    return _blockdev_getsz (g, device);
  }
  private native long _blockdev_getsz (long g, String device)
    throws LibGuestFSException;

  /**
   * get total size of device in bytes
   *
   * This returns the size of the device in bytes.
   * 
   * See also "g.blockdev_getsz".
   * 
   * This uses the blockdev(8) command.
   * 
   * @throws LibGuestFSException
   */
  public long blockdev_getsize64 (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_getsize64: handle is closed");
    return _blockdev_getsize64 (g, device);
  }
  private native long _blockdev_getsize64 (long g, String device)
    throws LibGuestFSException;

  /**
   * flush device buffers
   *
   * This tells the kernel to flush internal buffers
   * associated with "device".
   * 
   * This uses the blockdev(8) command.
   * 
   * @throws LibGuestFSException
   */
  public void blockdev_flushbufs (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_flushbufs: handle is closed");
    _blockdev_flushbufs (g, device);
  }
  private native void _blockdev_flushbufs (long g, String device)
    throws LibGuestFSException;

  /**
   * reread partition table
   *
   * Reread the partition table on "device".
   * 
   * This uses the blockdev(8) command.
   * 
   * @throws LibGuestFSException
   */
  public void blockdev_rereadpt (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("blockdev_rereadpt: handle is closed");
    _blockdev_rereadpt (g, device);
  }
  private native void _blockdev_rereadpt (long g, String device)
    throws LibGuestFSException;

  /**
   * upload a file from the local machine
   *
   * Upload local file "filename" to "remotefilename" on the
   * filesystem.
   * 
   * "filename" can also be a named pipe.
   * 
   * See also "g.download".
   * 
   * @throws LibGuestFSException
   */
  public void upload (String filename, String remotefilename)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("upload: handle is closed");
    _upload (g, filename, remotefilename);
  }
  private native void _upload (long g, String filename, String remotefilename)
    throws LibGuestFSException;

  /**
   * download a file to the local machine
   *
   * Download file "remotefilename" and save it as "filename"
   * on the local machine.
   * 
   * "filename" can also be a named pipe.
   * 
   * See also "g.upload", "g.cat".
   * 
   * @throws LibGuestFSException
   */
  public void download (String remotefilename, String filename)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("download: handle is closed");
    _download (g, remotefilename, filename);
  }
  private native void _download (long g, String remotefilename, String filename)
    throws LibGuestFSException;

  /**
   * compute MD5, SHAx or CRC checksum of file
   *
   * This call computes the MD5, SHAx or CRC checksum of the
   * file named "path".
   * 
   * The type of checksum to compute is given by the
   * "csumtype" parameter which must have one of the
   * following values:
   * 
   * "crc"
   * Compute the cyclic redundancy check (CRC) specified
   * by POSIX for the "cksum" command.
   * 
   * "md5"
   * Compute the MD5 hash (using the "md5sum" program).
   * 
   * "sha1"
   * Compute the SHA1 hash (using the "sha1sum" program).
   * 
   * "sha224"
   * Compute the SHA224 hash (using the "sha224sum"
   * program).
   * 
   * "sha256"
   * Compute the SHA256 hash (using the "sha256sum"
   * program).
   * 
   * "sha384"
   * Compute the SHA384 hash (using the "sha384sum"
   * program).
   * 
   * "sha512"
   * Compute the SHA512 hash (using the "sha512sum"
   * program).
   * 
   * The checksum is returned as a printable string.
   * 
   * @throws LibGuestFSException
   */
  public String checksum (String csumtype, String path)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("checksum: handle is closed");
    return _checksum (g, csumtype, path);
  }
  private native String _checksum (long g, String csumtype, String path)
    throws LibGuestFSException;

  /**
   * unpack tarfile to directory
   *
   * This command uploads and unpacks local file "tarfile"
   * (an *uncompressed* tar file) into "directory".
   * 
   * To upload a compressed tarball, use "g.tgz_in".
   * 
   * @throws LibGuestFSException
   */
  public void tar_in (String tarfile, String directory)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("tar_in: handle is closed");
    _tar_in (g, tarfile, directory);
  }
  private native void _tar_in (long g, String tarfile, String directory)
    throws LibGuestFSException;

  /**
   * pack directory into tarfile
   *
   * This command packs the contents of "directory" and
   * downloads it to local file "tarfile".
   * 
   * To download a compressed tarball, use "g.tgz_out".
   * 
   * @throws LibGuestFSException
   */
  public void tar_out (String directory, String tarfile)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("tar_out: handle is closed");
    _tar_out (g, directory, tarfile);
  }
  private native void _tar_out (long g, String directory, String tarfile)
    throws LibGuestFSException;

  /**
   * unpack compressed tarball to directory
   *
   * This command uploads and unpacks local file "tarball" (a
   * *gzip compressed* tar file) into "directory".
   * 
   * To upload an uncompressed tarball, use "g.tar_in".
   * 
   * @throws LibGuestFSException
   */
  public void tgz_in (String tarball, String directory)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("tgz_in: handle is closed");
    _tgz_in (g, tarball, directory);
  }
  private native void _tgz_in (long g, String tarball, String directory)
    throws LibGuestFSException;

  /**
   * pack directory into compressed tarball
   *
   * This command packs the contents of "directory" and
   * downloads it to local file "tarball".
   * 
   * To download an uncompressed tarball, use "g.tar_out".
   * 
   * @throws LibGuestFSException
   */
  public void tgz_out (String directory, String tarball)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("tgz_out: handle is closed");
    _tgz_out (g, directory, tarball);
  }
  private native void _tgz_out (long g, String directory, String tarball)
    throws LibGuestFSException;

  /**
   * mount a guest disk, read-only
   *
   * This is the same as the "g.mount" command, but it mounts
   * the filesystem with the read-only (*-o ro*) flag.
   * 
   * @throws LibGuestFSException
   */
  public void mount_ro (String device, String mountpoint)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mount_ro: handle is closed");
    _mount_ro (g, device, mountpoint);
  }
  private native void _mount_ro (long g, String device, String mountpoint)
    throws LibGuestFSException;

  /**
   * mount a guest disk with mount options
   *
   * This is the same as the "g.mount" command, but it allows
   * you to set the mount options as for the mount(8) *-o*
   * flag.
   * 
   * @throws LibGuestFSException
   */
  public void mount_options (String options, String device, String mountpoint)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mount_options: handle is closed");
    _mount_options (g, options, device, mountpoint);
  }
  private native void _mount_options (long g, String options, String device, String mountpoint)
    throws LibGuestFSException;

  /**
   * mount a guest disk with mount options and vfstype
   *
   * This is the same as the "g.mount" command, but it allows
   * you to set both the mount options and the vfstype as for
   * the mount(8) *-o* and *-t* flags.
   * 
   * @throws LibGuestFSException
   */
  public void mount_vfs (String options, String vfstype, String device, String mountpoint)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("mount_vfs: handle is closed");
    _mount_vfs (g, options, vfstype, device, mountpoint);
  }
  private native void _mount_vfs (long g, String options, String vfstype, String device, String mountpoint)
    throws LibGuestFSException;

  /**
   * debugging and internals
   *
   * The "g.debug" command exposes some internals of
   * "guestfsd" (the guestfs daemon) that runs inside the
   * qemu subprocess.
   * 
   * There is no comprehensive help for this command. You
   * have to look at the file "daemon/debug.c" in the
   * libguestfs source to find out what you can do.
   * 
   * @throws LibGuestFSException
   */
  public String debug (String subcmd, String[] extraargs)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("debug: handle is closed");
    return _debug (g, subcmd, extraargs);
  }
  private native String _debug (long g, String subcmd, String[] extraargs)
    throws LibGuestFSException;

  /**
   * remove an LVM logical volume
   *
   * Remove an LVM logical volume "device", where "device" is
   * the path to the LV, such as "/dev/VG/LV".
   * 
   * You can also remove all LVs in a volume group by
   * specifying the VG name, "/dev/VG".
   * 
   * @throws LibGuestFSException
   */
  public void lvremove (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("lvremove: handle is closed");
    _lvremove (g, device);
  }
  private native void _lvremove (long g, String device)
    throws LibGuestFSException;

  /**
   * remove an LVM volume group
   *
   * Remove an LVM volume group "vgname", (for example "VG").
   * 
   * This also forcibly removes all logical volumes in the
   * volume group (if any).
   * 
   * @throws LibGuestFSException
   */
  public void vgremove (String vgname)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("vgremove: handle is closed");
    _vgremove (g, vgname);
  }
  private native void _vgremove (long g, String vgname)
    throws LibGuestFSException;

  /**
   * remove an LVM physical volume
   *
   * This wipes a physical volume "device" so that LVM will
   * no longer recognise it.
   * 
   * The implementation uses the "pvremove" command which
   * refuses to wipe physical volumes that contain any volume
   * groups, so you have to remove those first.
   * 
   * @throws LibGuestFSException
   */
  public void pvremove (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("pvremove: handle is closed");
    _pvremove (g, device);
  }
  private native void _pvremove (long g, String device)
    throws LibGuestFSException;

  /**
   * set the ext2/3/4 filesystem label
   *
   * This sets the ext2/3/4 filesystem label of the
   * filesystem on "device" to "label". Filesystem labels are
   * limited to 16 characters.
   * 
   * You can use either "g.tune2fs_l" or "g.get_e2label" to
   * return the existing label on a filesystem.
   * 
   * @throws LibGuestFSException
   */
  public void set_e2label (String device, String label)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_e2label: handle is closed");
    _set_e2label (g, device, label);
  }
  private native void _set_e2label (long g, String device, String label)
    throws LibGuestFSException;

  /**
   * get the ext2/3/4 filesystem label
   *
   * This returns the ext2/3/4 filesystem label of the
   * filesystem on "device".
   * 
   * @throws LibGuestFSException
   */
  public String get_e2label (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("get_e2label: handle is closed");
    return _get_e2label (g, device);
  }
  private native String _get_e2label (long g, String device)
    throws LibGuestFSException;

  /**
   * set the ext2/3/4 filesystem UUID
   *
   * This sets the ext2/3/4 filesystem UUID of the filesystem
   * on "device" to "uuid". The format of the UUID and
   * alternatives such as "clear", "random" and "time" are
   * described in the tune2fs(8) manpage.
   * 
   * You can use either "g.tune2fs_l" or "g.get_e2uuid" to
   * return the existing UUID of a filesystem.
   * 
   * @throws LibGuestFSException
   */
  public void set_e2uuid (String device, String uuid)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("set_e2uuid: handle is closed");
    _set_e2uuid (g, device, uuid);
  }
  private native void _set_e2uuid (long g, String device, String uuid)
    throws LibGuestFSException;

  /**
   * get the ext2/3/4 filesystem UUID
   *
   * This returns the ext2/3/4 filesystem UUID of the
   * filesystem on "device".
   * 
   * @throws LibGuestFSException
   */
  public String get_e2uuid (String device)
    throws LibGuestFSException
  {
    if (g == 0)
      throw new LibGuestFSException ("get_e2uuid: handle is closed");
    return _get_e2uuid (g, device);
  }
  private native String _get_e2uuid (long g, String device)
    throws LibGuestFSException;

}
