/* libguestfs generated file
 * WARNING: THIS FILE IS GENERATED BY 'src/generator.ml'.
 * ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.
 *
 * Copyright (C) 2009 Red Hat Inc.
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along
 * with this program; if not, write to the Free Software Foundation, Inc.,
 * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
 */

#include <rpc/types.h>
#include <rpc/xdr.h>
#include "daemon.h"
#include "../src/guestfs_protocol.h"
#include "actions.h"

static void mount_stub (XDR *xdr_in)
{
  int r;
  struct guestfs_mount_args args;
  const char *device;
  const char *mountpoint;

  memset (&args, 0, sizeof args);

  if (!xdr_guestfs_mount_args (xdr_in, &args)) {
    reply_with_error ("mount: daemon failed to decode procedure arguments");
    return;
  }
  device = args.device;
  mountpoint = args.mountpoint;

  r = do_mount (device, mountpoint);
  if (r == -1)
    /* do_mount has already called reply_with_error, so just return */
    return;

  reply (NULL, NULL);
}

static void sync_stub (XDR *xdr_in)
{
  int r;

  r = do_sync ();
  if (r == -1)
    /* do_sync has already called reply_with_error, so just return */
    return;

  reply (NULL, NULL);
}

static void touch_stub (XDR *xdr_in)
{
  int r;
  struct guestfs_touch_args args;
  const char *path;

  memset (&args, 0, sizeof args);

  if (!xdr_guestfs_touch_args (xdr_in, &args)) {
    reply_with_error ("touch: daemon failed to decode procedure arguments");
    return;
  }
  path = args.path;

  r = do_touch (path);
  if (r == -1)
    /* do_touch has already called reply_with_error, so just return */
    return;

  reply (NULL, NULL);
}

static void cat_stub (XDR *xdr_in)
{
  char *r;
  struct guestfs_cat_args args;
  const char *path;

  memset (&args, 0, sizeof args);

  if (!xdr_guestfs_cat_args (xdr_in, &args)) {
    reply_with_error ("cat: daemon failed to decode procedure arguments");
    return;
  }
  path = args.path;

  r = do_cat (path);
  if (r == NULL)
    /* do_cat has already called reply_with_error, so just return */
    return;

  struct guestfs_cat_ret ret;
  ret.content = r;
  reply ((xdrproc_t) &xdr_guestfs_cat_ret, (char *) &ret);
  free (r);
}

static void ll_stub (XDR *xdr_in)
{
  char *r;
  struct guestfs_ll_args args;
  const char *directory;

  memset (&args, 0, sizeof args);

  if (!xdr_guestfs_ll_args (xdr_in, &args)) {
    reply_with_error ("ll: daemon failed to decode procedure arguments");
    return;
  }
  directory = args.directory;

  r = do_ll (directory);
  if (r == NULL)
    /* do_ll has already called reply_with_error, so just return */
    return;

  struct guestfs_ll_ret ret;
  ret.listing = r;
  reply ((xdrproc_t) &xdr_guestfs_ll_ret, (char *) &ret);
  free (r);
}

static void ls_stub (XDR *xdr_in)
{
  char **r;
  struct guestfs_ls_args args;
  const char *directory;

  memset (&args, 0, sizeof args);

  if (!xdr_guestfs_ls_args (xdr_in, &args)) {
    reply_with_error ("ls: daemon failed to decode procedure arguments");
    return;
  }
  directory = args.directory;

  r = do_ls (directory);
  if (r == NULL)
    /* do_ls has already called reply_with_error, so just return */
    return;

  struct guestfs_ls_ret ret;
  ret.listing.listing_len = count_strings (r);
  ret.listing.listing_val = r;
  reply ((xdrproc_t) &xdr_guestfs_ls_ret, (char *) &ret);
  free_strings (r);
}

static void list_devices_stub (XDR *xdr_in)
{
  char **r;

  r = do_list_devices ();
  if (r == NULL)
    /* do_list_devices has already called reply_with_error, so just return */
    return;

  struct guestfs_list_devices_ret ret;
  ret.devices.devices_len = count_strings (r);
  ret.devices.devices_val = r;
  reply ((xdrproc_t) &xdr_guestfs_list_devices_ret, (char *) &ret);
  free_strings (r);
}

static void list_partitions_stub (XDR *xdr_in)
{
  char **r;

  r = do_list_partitions ();
  if (r == NULL)
    /* do_list_partitions has already called reply_with_error, so just return */
    return;

  struct guestfs_list_partitions_ret ret;
  ret.partitions.partitions_len = count_strings (r);
  ret.partitions.partitions_val = r;
  reply ((xdrproc_t) &xdr_guestfs_list_partitions_ret, (char *) &ret);
  free_strings (r);
}

void dispatch_incoming_message (XDR *xdr_in)
{
  switch (proc_nr) {
    case GUESTFS_PROC_MOUNT:
      mount_stub (xdr_in);
      break;
    case GUESTFS_PROC_SYNC:
      sync_stub (xdr_in);
      break;
    case GUESTFS_PROC_TOUCH:
      touch_stub (xdr_in);
      break;
    case GUESTFS_PROC_CAT:
      cat_stub (xdr_in);
      break;
    case GUESTFS_PROC_LL:
      ll_stub (xdr_in);
      break;
    case GUESTFS_PROC_LS:
      ls_stub (xdr_in);
      break;
    case GUESTFS_PROC_LIST_DEVICES:
      list_devices_stub (xdr_in);
      break;
    case GUESTFS_PROC_LIST_PARTITIONS:
      list_partitions_stub (xdr_in);
      break;
    default:
      reply_with_error ("dispatch_incoming_message: unknown procedure number %d", proc_nr);
  }
}
