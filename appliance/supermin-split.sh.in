#!/bin/bash -
# @configure_input@
# Copyright (C) 2009 Red Hat Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

# Decide which files will stay in the supermin appliance and which
# files will be pulled out of the host at runtime.
#
# Read the README file!
#
# The basic idea is that we create two output files, one containing
# the files that will stay, and the other listing the files that
# will be pulled from the host (ie. not go into the appliance now).
#
# The list of files that stay ('supermin.incfiles') is just a straight
# list of files and directories.
#
# The list of files that come from the host ('*.supermin.hostfiles')
# can include wildcards, to allow libraries to be upgraded on the
# host.

unset CDPATH

set -e

cd @top_builddir@/initramfs

incfiles=../appliance/supermin.incfiles
hostfiles=../appliance/initramfs.@REPO@.@host_cpu@.supermin.hostfiles

exec 5>$incfiles
exec 6>$hostfiles

# Note currently the initramfs contains ~2500 files, and none have
# "funny characters" in the names.  So this is reasonable just to
# simplify the script.
for path in $(find -not -name fakeroot.log); do
    dir=$(dirname "$path")
    file=$(basename "$path")

    # For quoting problems with the bash =~ operator, see bash FAQ
    # question E14 here http://tiswww.case.edu/php/chet/bash/FAQ and
    # http://bugs.debian.org/cgi-bin/bugreport.cgi?bug=487387#25
    # (RHBZ#566511).
    p_etc='^\./etc'
    p_dev='^\./dev'
    p_var='^\./var'
    p_lib_modules='^\./lib/modules/'
    p_builddir='^\./builddir'
    p_ld_so='^ld-[.0-9]+\.so$'
    p_libbfd='^libbfd-.*\.so$'
    p_libgcc='^libgcc_s-.*\.so\.([0-9]+)$'
    p_libntfs3g='^libntfs-3g\.so\..*$'
    p_lib123so='^lib(.*)-[-.0-9]+\.so$'
    p_lib123so123='^lib(.*)-[-.0-9]+\.so\.([0-9]+)\.'
    p_libso123='^lib(.*)\.so\.([0-9]+)\.'

    # All we're going to keep are the special files /init, the daemon,
    # configuration files (/etc), devices and modifiable stuff (/var).
    if [ "$path" = "./init" -o "$file" = "guestfsd" ]; then
        echo "$path" >&5

    elif [[ "$path" =~ $p_etc || "$path" =~ $p_dev || "$path" =~ $p_var ]]
    then
        echo "$path" >&5

    # Kernel modules are always copied in from the host, including all
    # the dependency files.
    elif [[ "$path" =~ $p_lib_modules ]]; then
        :

    # On mock/Koji, exclude bogus /builddir directory which for some
    # reason contains some yum temporary files (RHBZ#566512).
    elif [[ "$path" =~ $p_builddir ]]; then
        :

    elif [ -d "$path" ]; then
        # Always write directory names to both output files.
        echo "$path" >&5
        echo "$path" >&6

    # Some libraries need fixed version numbers replaced by wildcards.

    elif [[ "$file" =~ $p_ld_so ]]; then
        echo "$dir/ld-*.so" >&6

    # Special case for libbfd
    elif [[ "$file" =~ $p_libbfd ]]; then
        echo "$dir/libbfd-*.so" >&6

    # Special case for libgcc_s-<gccversion>-<date>.so.N
    elif [[ "$file" =~ $p_libgcc ]]; then
        echo "$dir/libgcc_s-*.so.${BASH_REMATCH[1]}" >&6

    # Special case for libntfs-3g.so.*
    elif [[ "$file" =~ $p_libntfs3g ]]; then
        [ -n "$libntfs3g_once" ] || echo "$dir/libntfs-3g.so.*" >&6
        libntfs3g_once=1

    # libfoo-1.2.3.so
    elif [[ "$file" =~ $p_lib123so ]]; then
        echo "$dir/lib${BASH_REMATCH[1]}-*.so" >&6

    # libfoo-1.2.3.so.1.2.3 (but NOT '*.so.N')
    elif [[ "$file" =~ $p_lib123so123 ]]; then
        echo "$dir/lib${BASH_REMATCH[1]}-*.so.${BASH_REMATCH[2]}.*" >&6

    # libfoo.so.1.2.3 (but NOT '*.so.N')
    elif [[ "$file" =~ $p_libso123 ]]; then
        echo "$dir/lib${BASH_REMATCH[1]}.so.${BASH_REMATCH[2]}.*" >&6

    else
        # Anything else comes from the host directly.
        echo "$path" >&6
    fi
done
