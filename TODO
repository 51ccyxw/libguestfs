Ideas for the Python bindings:
https://www.redhat.com/archives/fedora-virt/2009-April/msg00114.html

----------------------------------------------------------------------

We badly need to actually implement the FTP server mentioned in the
documentation.

Or: Implement a FUSE-based filesystem.  See the FUSE mountlo
project which does something similar, albeit only to single
filesystems:

http://sourceforge.net/project/showfiles.php?group_id=121684&package_id=150116

----------------------------------------------------------------------

BufferIn and BufferOut should turn into <char *, int> and simple
strings in other languages that can handle 8 bit clean strings.
Limit on transfers would still be 2MB for these types.
 - then implement write-file properly
 - and implement read-file

----------------------------------------------------------------------

Implement febootstrap command.

----------------------------------------------------------------------

Complete the Haskell bindings (see discussion on haskell-cafe).

----------------------------------------------------------------------

Complete the bindings tests - must test the return values and
error cases.

----------------------------------------------------------------------

For virt-inspector:

 - Make a libvirt XML config

 - Test over available OSes

 - Add 'reged' / NT registry support.

----------------------------------------------------------------------

Use virtio_blk by default.  It's faster and more natural.
Unfortunately it seems like this will rename all devices - see next
item.

Note: virtio_blk *IS* supported by all our minimum platforms,
ie. CentOS 5.3, Fedora 11, Debian.

----------------------------------------------------------------------

"Device independent" naming for devices.

With a Fedora-based appliance, using libata driver, devices have
"SCSI" names like /dev/sda.

With an EPEL-based appliance, using old ide driver, devices have names
like /dev/hda.

If we use virtio_blk, devices will have names like /dev/vda.

What a mess.

So the idea would be to add a device independent naming scheme, such
as the one used by grub:

  "(hdX)"   X = 0 means 'a', X = 1 means 'b' and so on.
  "(hdX,Y)" Device X, partition Y (in grub, this counts from 0 which is
            deeply confusing).

There would have to be a very simple rule.  If guestfsd was expecting
a /dev block device or partition name, then the alternate form can be
used, and we would just look it up using the normal output of
guestfs_list_devices.

Maybe best is to use /dev/sda as the "standard" naming.  That
shouldn't cause conflicts in the appliance because we tightly control
what drivers are available.

Note there's a lot of hackery that currently exists in tests.c which
could be *removed* if we made this change.

Open: Should the substitution be done in the library layer or in the
daemon?

----------------------------------------------------------------------

Qemu options -- After discussion with the KVM developers, they have
recommended some flags which will improve the safety and reliability
of KVM.  Need to test that these also work under qemu (or at least, do
no harm):

-no-hpet      HPET support is broken and should be disabled.

-rtc-td-hack  Keeps the rtc clock source track time correctly.

-drive file=...,if=[ide|virtio],cache=off
              cache=off is necessary to improve reliability in the
	      event of a system crash when writing.

----------------------------------------------------------------------

"Standalone/local mode"

Instead of running guestfsd (the daemon) inside qemu, there should be
an option to just run guestfsd directly.

The architecture in this mode would look like:

     +------------------+
     | main program     |
     |------------------|
     | libguestfs       |
     +--------^---------+
          |   | reply
      cmd |   |
     +----v-------------+
     | guestfsd         |
     +------------------+

Notes:

(1) This only makes sense if we are running as root.

(2) There is no console / kernel messages in this configuration, but
we might consider capturing stderr from the daemon.

(3) guestfs_config and guestfs_add_drive become no-ops.

Obviously in this configuration, commands are run directly on the
local machine's disks.  You could just run the commands themselves
directly, but libguestfs provides a convenient API and language
bindings.  Also deals with tricky stuff like parsing the output of the
LVM commands.  Also we get to leverage other code such as
virt-inspector.

This is mainly useful from live CDs, ie. virt-p2v.

Should we bother having the daemon at all and just link the guestfsd
code directly into libguestfs?
