/* libguestfs generated file
 * WARNING: THIS FILE IS GENERATED BY 'src/generator.ml'.
 * ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.
 *
 * Copyright (C) 2009 Red Hat Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

struct mount_rv {
  int err_code;      /* 0 OK or -1 error */
  int serial;        /* serial number of reply */
  char err_str[GUESTFS_ERROR_LEN]; /* error from daemon */
};

static void mount_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct mount_rv *rv = (struct mount_rv *) data;

  /* XXX */ rv->err_code = 0;
  /* XXX rv->serial = ?; */
  main_loop.main_loop_quit (g);
}

int guestfs_mount (guestfs_h *g,
		const char *device,
		const char *mountpoint)
{
  struct guestfs_mount_args args;
  struct mount_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_mount called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  args.device = (char *) device;
  args.mountpoint = (char *) mountpoint;
  serial = dispatch (g, GUESTFS_PROC_MOUNT,
                     (xdrproc_t) xdr_guestfs_mount_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.err_code = 42;
  g->reply_cb_internal = mount_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (rv.err_code == 42) { /* callback wasn't called */
    error (g, "guestfs_mount failed, see earlier error messages");
    return -1;
  }
  else if (rv.err_code == -1) { /* error from remote end */
    error (g, "%s", rv.err_str);
    return -1;
  }

  /* XXX check serial number agrees */

  return 0;
}

struct sync_rv {
  int err_code;      /* 0 OK or -1 error */
  int serial;        /* serial number of reply */
  char err_str[GUESTFS_ERROR_LEN]; /* error from daemon */
};

static void sync_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct sync_rv *rv = (struct sync_rv *) data;

  /* XXX */ rv->err_code = 0;
  /* XXX rv->serial = ?; */
  main_loop.main_loop_quit (g);
}

int guestfs_sync (guestfs_h *g)
{
  struct sync_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_sync called from the wrong state, %d != READY",
      g->state);
    return -1;
  }
  serial = dispatch (g, GUESTFS_PROC_SYNC, NULL, NULL);
  if (serial == -1)
    return -1;

  rv.err_code = 42;
  g->reply_cb_internal = sync_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (rv.err_code == 42) { /* callback wasn't called */
    error (g, "guestfs_sync failed, see earlier error messages");
    return -1;
  }
  else if (rv.err_code == -1) { /* error from remote end */
    error (g, "%s", rv.err_str);
    return -1;
  }

  /* XXX check serial number agrees */

  return 0;
}

struct touch_rv {
  int err_code;      /* 0 OK or -1 error */
  int serial;        /* serial number of reply */
  char err_str[GUESTFS_ERROR_LEN]; /* error from daemon */
};

static void touch_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct touch_rv *rv = (struct touch_rv *) data;

  /* XXX */ rv->err_code = 0;
  /* XXX rv->serial = ?; */
  main_loop.main_loop_quit (g);
}

int guestfs_touch (guestfs_h *g,
		const char *path)
{
  struct guestfs_touch_args args;
  struct touch_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_touch called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_TOUCH,
                     (xdrproc_t) xdr_guestfs_touch_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.err_code = 42;
  g->reply_cb_internal = touch_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (rv.err_code == 42) { /* callback wasn't called */
    error (g, "guestfs_touch failed, see earlier error messages");
    return -1;
  }
  else if (rv.err_code == -1) { /* error from remote end */
    error (g, "%s", rv.err_str);
    return -1;
  }

  /* XXX check serial number agrees */

  return 0;
}

