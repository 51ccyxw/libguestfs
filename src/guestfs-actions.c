/* libguestfs generated file
 * WARNING: THIS FILE IS GENERATED BY 'src/generator.ml'.
 * ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.
 *
 * Copyright (C) 2009 Red Hat Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

struct mount_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mount_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct mount_rv *rv = (struct mount_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_mount: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_mount: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_mount (guestfs_h *g,
		const char *device,
		const char *mountpoint)
{
  struct guestfs_mount_args args;
  struct mount_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_mount called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.device = (char *) device;
  args.mountpoint = (char *) mountpoint;
  serial = dispatch (g, GUESTFS_PROC_MOUNT,
                     (xdrproc_t) xdr_guestfs_mount_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = mount_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_mount failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_MOUNT, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct sync_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void sync_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct sync_rv *rv = (struct sync_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_sync: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_sync: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_sync (guestfs_h *g)
{
  struct sync_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_sync called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_SYNC, NULL, NULL);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = sync_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_sync failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_SYNC, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct touch_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void touch_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct touch_rv *rv = (struct touch_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_touch: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_touch: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_touch (guestfs_h *g,
		const char *path)
{
  struct guestfs_touch_args args;
  struct touch_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_touch called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_TOUCH,
                     (xdrproc_t) xdr_guestfs_touch_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = touch_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_touch failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_TOUCH, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct cat_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_cat_ret ret;
};

static void cat_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct cat_rv *rv = (struct cat_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_cat: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_cat: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_cat_ret (xdr, &rv->ret)) {
    error (g, "guestfs_cat: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char *guestfs_cat (guestfs_h *g,
		const char *path)
{
  struct guestfs_cat_args args;
  struct cat_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_cat called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_CAT,
                     (xdrproc_t) xdr_guestfs_cat_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = cat_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_cat failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_CAT, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  return rv.ret.content; /* caller will free */
}

struct ll_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_ll_ret ret;
};

static void ll_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct ll_rv *rv = (struct ll_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_ll: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_ll: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_ll_ret (xdr, &rv->ret)) {
    error (g, "guestfs_ll: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char *guestfs_ll (guestfs_h *g,
		const char *directory)
{
  struct guestfs_ll_args args;
  struct ll_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_ll called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.directory = (char *) directory;
  serial = dispatch (g, GUESTFS_PROC_LL,
                     (xdrproc_t) xdr_guestfs_ll_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = ll_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_ll failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_LL, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  return rv.ret.listing; /* caller will free */
}

struct ls_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_ls_ret ret;
};

static void ls_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct ls_rv *rv = (struct ls_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_ls: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_ls: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_ls_ret (xdr, &rv->ret)) {
    error (g, "guestfs_ls: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_ls (guestfs_h *g,
		const char *directory)
{
  struct guestfs_ls_args args;
  struct ls_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_ls called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.directory = (char *) directory;
  serial = dispatch (g, GUESTFS_PROC_LS,
                     (xdrproc_t) xdr_guestfs_ls_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = ls_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_ls failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_LS, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.listing.listing_val =    safe_realloc (g, rv.ret.listing.listing_val,
                  sizeof (char *) * (rv.ret.listing.listing_len + 1));
  rv.ret.listing.listing_val[rv.ret.listing.listing_len] = NULL;
  return rv.ret.listing.listing_val;
}

struct list_devices_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_list_devices_ret ret;
};

static void list_devices_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct list_devices_rv *rv = (struct list_devices_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_list_devices: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_list_devices: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_list_devices_ret (xdr, &rv->ret)) {
    error (g, "guestfs_list_devices: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_list_devices (guestfs_h *g)
{
  struct list_devices_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_list_devices called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_LIST_DEVICES, NULL, NULL);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = list_devices_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_list_devices failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_LIST_DEVICES, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.devices.devices_val =    safe_realloc (g, rv.ret.devices.devices_val,
                  sizeof (char *) * (rv.ret.devices.devices_len + 1));
  rv.ret.devices.devices_val[rv.ret.devices.devices_len] = NULL;
  return rv.ret.devices.devices_val;
}

struct list_partitions_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_list_partitions_ret ret;
};

static void list_partitions_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct list_partitions_rv *rv = (struct list_partitions_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_list_partitions: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_list_partitions: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_list_partitions_ret (xdr, &rv->ret)) {
    error (g, "guestfs_list_partitions: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_list_partitions (guestfs_h *g)
{
  struct list_partitions_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_list_partitions called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_LIST_PARTITIONS, NULL, NULL);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = list_partitions_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_list_partitions failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_LIST_PARTITIONS, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.partitions.partitions_val =    safe_realloc (g, rv.ret.partitions.partitions_val,
                  sizeof (char *) * (rv.ret.partitions.partitions_len + 1));
  rv.ret.partitions.partitions_val[rv.ret.partitions.partitions_len] = NULL;
  return rv.ret.partitions.partitions_val;
}

struct pvs_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_pvs_ret ret;
};

static void pvs_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct pvs_rv *rv = (struct pvs_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_pvs: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_pvs: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_pvs_ret (xdr, &rv->ret)) {
    error (g, "guestfs_pvs: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_pvs (guestfs_h *g)
{
  struct pvs_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_pvs called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_PVS, NULL, NULL);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = pvs_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_pvs failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_PVS, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.physvols.physvols_val =    safe_realloc (g, rv.ret.physvols.physvols_val,
                  sizeof (char *) * (rv.ret.physvols.physvols_len + 1));
  rv.ret.physvols.physvols_val[rv.ret.physvols.physvols_len] = NULL;
  return rv.ret.physvols.physvols_val;
}

struct vgs_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_vgs_ret ret;
};

static void vgs_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct vgs_rv *rv = (struct vgs_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_vgs: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_vgs: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_vgs_ret (xdr, &rv->ret)) {
    error (g, "guestfs_vgs: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_vgs (guestfs_h *g)
{
  struct vgs_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_vgs called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_VGS, NULL, NULL);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = vgs_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_vgs failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_VGS, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.volgroups.volgroups_val =    safe_realloc (g, rv.ret.volgroups.volgroups_val,
                  sizeof (char *) * (rv.ret.volgroups.volgroups_len + 1));
  rv.ret.volgroups.volgroups_val[rv.ret.volgroups.volgroups_len] = NULL;
  return rv.ret.volgroups.volgroups_val;
}

struct lvs_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_lvs_ret ret;
};

static void lvs_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct lvs_rv *rv = (struct lvs_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_lvs: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_lvs: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_lvs_ret (xdr, &rv->ret)) {
    error (g, "guestfs_lvs: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_lvs (guestfs_h *g)
{
  struct lvs_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_lvs called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_LVS, NULL, NULL);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = lvs_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_lvs failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_LVS, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.logvols.logvols_val =    safe_realloc (g, rv.ret.logvols.logvols_val,
                  sizeof (char *) * (rv.ret.logvols.logvols_len + 1));
  rv.ret.logvols.logvols_val[rv.ret.logvols.logvols_len] = NULL;
  return rv.ret.logvols.logvols_val;
}

struct pvs_full_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_pvs_full_ret ret;
};

static void pvs_full_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct pvs_full_rv *rv = (struct pvs_full_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_pvs_full: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_pvs_full: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_pvs_full_ret (xdr, &rv->ret)) {
    error (g, "guestfs_pvs_full: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

struct guestfs_lvm_pv_list *guestfs_pvs_full (guestfs_h *g)
{
  struct pvs_full_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_pvs_full called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_PVS_FULL, NULL, NULL);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = pvs_full_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_pvs_full failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_PVS_FULL, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this */
  return safe_memdup (g, &rv.ret.physvols, sizeof (rv.ret.physvols));
}

struct vgs_full_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_vgs_full_ret ret;
};

static void vgs_full_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct vgs_full_rv *rv = (struct vgs_full_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_vgs_full: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_vgs_full: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_vgs_full_ret (xdr, &rv->ret)) {
    error (g, "guestfs_vgs_full: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

struct guestfs_lvm_vg_list *guestfs_vgs_full (guestfs_h *g)
{
  struct vgs_full_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_vgs_full called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_VGS_FULL, NULL, NULL);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = vgs_full_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_vgs_full failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_VGS_FULL, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this */
  return safe_memdup (g, &rv.ret.volgroups, sizeof (rv.ret.volgroups));
}

struct lvs_full_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_lvs_full_ret ret;
};

static void lvs_full_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct lvs_full_rv *rv = (struct lvs_full_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_lvs_full: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_lvs_full: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_lvs_full_ret (xdr, &rv->ret)) {
    error (g, "guestfs_lvs_full: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

struct guestfs_lvm_lv_list *guestfs_lvs_full (guestfs_h *g)
{
  struct lvs_full_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_lvs_full called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_LVS_FULL, NULL, NULL);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = lvs_full_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_lvs_full failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_LVS_FULL, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this */
  return safe_memdup (g, &rv.ret.logvols, sizeof (rv.ret.logvols));
}

struct read_lines_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_read_lines_ret ret;
};

static void read_lines_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct read_lines_rv *rv = (struct read_lines_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_read_lines: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_read_lines: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_read_lines_ret (xdr, &rv->ret)) {
    error (g, "guestfs_read_lines: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_read_lines (guestfs_h *g,
		const char *path)
{
  struct guestfs_read_lines_args args;
  struct read_lines_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_read_lines called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_READ_LINES,
                     (xdrproc_t) xdr_guestfs_read_lines_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = read_lines_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_read_lines failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_READ_LINES, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.lines.lines_val =    safe_realloc (g, rv.ret.lines.lines_val,
                  sizeof (char *) * (rv.ret.lines.lines_len + 1));
  rv.ret.lines.lines_val[rv.ret.lines.lines_len] = NULL;
  return rv.ret.lines.lines_val;
}

struct aug_init_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_init_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_init_rv *rv = (struct aug_init_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_init: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_init: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_init (guestfs_h *g,
		const char *root,
		int flags)
{
  struct guestfs_aug_init_args args;
  struct aug_init_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_init called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.root = (char *) root;
  args.flags = flags;
  serial = dispatch (g, GUESTFS_PROC_AUG_INIT,
                     (xdrproc_t) xdr_guestfs_aug_init_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_init_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_init failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_INIT, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct aug_close_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_close_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_close_rv *rv = (struct aug_close_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_close: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_close: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_close (guestfs_h *g)
{
  struct aug_close_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_close called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_AUG_CLOSE, NULL, NULL);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_close_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_close failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_CLOSE, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct aug_defvar_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_defvar_ret ret;
};

static void aug_defvar_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_defvar_rv *rv = (struct aug_defvar_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_defvar: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_defvar: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_defvar_ret (xdr, &rv->ret)) {
    error (g, "guestfs_aug_defvar: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_defvar (guestfs_h *g,
		const char *name,
		const char *expr)
{
  struct guestfs_aug_defvar_args args;
  struct aug_defvar_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_defvar called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.name = (char *) name;
  args.expr = expr ? (char **) &expr : NULL;
  serial = dispatch (g, GUESTFS_PROC_AUG_DEFVAR,
                     (xdrproc_t) xdr_guestfs_aug_defvar_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_defvar_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_defvar failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_DEFVAR, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return rv.ret.nrnodes;
}

struct aug_defnode_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_defnode_ret ret;
};

static void aug_defnode_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_defnode_rv *rv = (struct aug_defnode_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_defnode: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_defnode: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_defnode_ret (xdr, &rv->ret)) {
    error (g, "guestfs_aug_defnode: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

struct guestfs_int_bool *guestfs_aug_defnode (guestfs_h *g,
		const char *name,
		const char *expr,
		const char *val)
{
  struct guestfs_aug_defnode_args args;
  struct aug_defnode_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_defnode called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.name = (char *) name;
  args.expr = (char *) expr;
  args.val = (char *) val;
  serial = dispatch (g, GUESTFS_PROC_AUG_DEFNODE,
                     (xdrproc_t) xdr_guestfs_aug_defnode_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_defnode_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_defnode failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_DEFNODE, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller with free this */
  return safe_memdup (g, &rv.ret, sizeof (rv.ret));
}

struct aug_get_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_get_ret ret;
};

static void aug_get_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_get_rv *rv = (struct aug_get_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_get: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_get: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_get_ret (xdr, &rv->ret)) {
    error (g, "guestfs_aug_get: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char *guestfs_aug_get (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_get_args args;
  struct aug_get_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_get called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_AUG_GET,
                     (xdrproc_t) xdr_guestfs_aug_get_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_get_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_get failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_GET, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  return rv.ret.val; /* caller will free */
}

struct aug_set_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_set_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_set_rv *rv = (struct aug_set_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_set: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_set: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_set (guestfs_h *g,
		const char *path,
		const char *val)
{
  struct guestfs_aug_set_args args;
  struct aug_set_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_set called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  args.val = (char *) val;
  serial = dispatch (g, GUESTFS_PROC_AUG_SET,
                     (xdrproc_t) xdr_guestfs_aug_set_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_set_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_set failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_SET, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct aug_insert_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_insert_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_insert_rv *rv = (struct aug_insert_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_insert: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_insert: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_insert (guestfs_h *g,
		const char *path,
		const char *label,
		int before)
{
  struct guestfs_aug_insert_args args;
  struct aug_insert_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_insert called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  args.label = (char *) label;
  args.before = before;
  serial = dispatch (g, GUESTFS_PROC_AUG_INSERT,
                     (xdrproc_t) xdr_guestfs_aug_insert_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_insert_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_insert failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_INSERT, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct aug_rm_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_rm_ret ret;
};

static void aug_rm_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_rm_rv *rv = (struct aug_rm_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_rm: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_rm: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_rm_ret (xdr, &rv->ret)) {
    error (g, "guestfs_aug_rm: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_rm (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_rm_args args;
  struct aug_rm_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_rm called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_AUG_RM,
                     (xdrproc_t) xdr_guestfs_aug_rm_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_rm_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_rm failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_RM, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return rv.ret.nrnodes;
}

struct aug_mv_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_mv_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_mv_rv *rv = (struct aug_mv_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_mv: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_mv: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_mv (guestfs_h *g,
		const char *src,
		const char *dest)
{
  struct guestfs_aug_mv_args args;
  struct aug_mv_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_mv called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.src = (char *) src;
  args.dest = (char *) dest;
  serial = dispatch (g, GUESTFS_PROC_AUG_MV,
                     (xdrproc_t) xdr_guestfs_aug_mv_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_mv_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_mv failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_MV, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct aug_match_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_match_ret ret;
};

static void aug_match_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_match_rv *rv = (struct aug_match_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_match: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_match: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_match_ret (xdr, &rv->ret)) {
    error (g, "guestfs_aug_match: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_aug_match (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_match_args args;
  struct aug_match_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_match called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_AUG_MATCH,
                     (xdrproc_t) xdr_guestfs_aug_match_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_match_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_match failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_MATCH, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.matches.matches_val =    safe_realloc (g, rv.ret.matches.matches_val,
                  sizeof (char *) * (rv.ret.matches.matches_len + 1));
  rv.ret.matches.matches_val[rv.ret.matches.matches_len] = NULL;
  return rv.ret.matches.matches_val;
}

struct aug_save_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_save_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_save_rv *rv = (struct aug_save_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_save: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_save: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_save (guestfs_h *g)
{
  struct aug_save_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_save called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_AUG_SAVE, NULL, NULL);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_save_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_save failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_SAVE, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct aug_load_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_load_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_load_rv *rv = (struct aug_load_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_load: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_load: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_load (guestfs_h *g)
{
  struct aug_load_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_load called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_AUG_LOAD, NULL, NULL);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_load_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_load failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_LOAD, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

