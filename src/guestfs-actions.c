/* libguestfs generated file
 * WARNING: THIS FILE IS GENERATED BY 'src/generator.ml'.
 * ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.
 *
 * Copyright (C) 2009 Red Hat Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

struct mount_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mount_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct mount_rv *rv = (struct mount_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_mount: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_mount: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_mount (guestfs_h *g,
		const char *device,
		const char *mountpoint)
{
  struct guestfs_mount_args args;
  struct mount_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_mount called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.device = (char *) device;
  args.mountpoint = (char *) mountpoint;
  serial = dispatch (g, GUESTFS_PROC_MOUNT,
                     (xdrproc_t) xdr_guestfs_mount_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = mount_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_mount failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_MOUNT, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct sync_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void sync_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct sync_rv *rv = (struct sync_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_sync: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_sync: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_sync (guestfs_h *g)
{
  struct sync_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_sync called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_SYNC, NULL, NULL);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = sync_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_sync failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_SYNC, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct touch_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void touch_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct touch_rv *rv = (struct touch_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_touch: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_touch: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_touch (guestfs_h *g,
		const char *path)
{
  struct guestfs_touch_args args;
  struct touch_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_touch called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_TOUCH,
                     (xdrproc_t) xdr_guestfs_touch_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = touch_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_touch failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_TOUCH, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct cat_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_cat_ret ret;
};

static void cat_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct cat_rv *rv = (struct cat_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_cat: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_cat: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_cat_ret (xdr, &rv->ret)) {
    error (g, "guestfs_cat: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char *guestfs_cat (guestfs_h *g,
		const char *path)
{
  struct guestfs_cat_args args;
  struct cat_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_cat called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_CAT,
                     (xdrproc_t) xdr_guestfs_cat_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = cat_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_cat failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_CAT, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  return rv.ret.content; /* caller will free */
}

struct ll_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_ll_ret ret;
};

static void ll_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct ll_rv *rv = (struct ll_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_ll: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_ll: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_ll_ret (xdr, &rv->ret)) {
    error (g, "guestfs_ll: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char *guestfs_ll (guestfs_h *g,
		const char *directory)
{
  struct guestfs_ll_args args;
  struct ll_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_ll called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.directory = (char *) directory;
  serial = dispatch (g, GUESTFS_PROC_LL,
                     (xdrproc_t) xdr_guestfs_ll_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = ll_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_ll failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_LL, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  return rv.ret.listing; /* caller will free */
}

struct ls_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_ls_ret ret;
};

static void ls_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct ls_rv *rv = (struct ls_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_ls: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_ls: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_ls_ret (xdr, &rv->ret)) {
    error (g, "guestfs_ls: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_ls (guestfs_h *g,
		const char *directory)
{
  struct guestfs_ls_args args;
  struct ls_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_ls called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.directory = (char *) directory;
  serial = dispatch (g, GUESTFS_PROC_LS,
                     (xdrproc_t) xdr_guestfs_ls_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = ls_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_ls failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_LS, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.listing.listing_val =    safe_realloc (g, rv.ret.listing.listing_val,
                  sizeof (char *) * (rv.ret.listing.listing_len + 1));
  rv.ret.listing.listing_val[rv.ret.listing.listing_len] = NULL;
  return rv.ret.listing.listing_val;
}

struct list_devices_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_list_devices_ret ret;
};

static void list_devices_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct list_devices_rv *rv = (struct list_devices_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_list_devices: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_list_devices: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_list_devices_ret (xdr, &rv->ret)) {
    error (g, "guestfs_list_devices: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_list_devices (guestfs_h *g)
{
  struct list_devices_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_list_devices called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_LIST_DEVICES, NULL, NULL);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = list_devices_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_list_devices failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_LIST_DEVICES, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.devices.devices_val =    safe_realloc (g, rv.ret.devices.devices_val,
                  sizeof (char *) * (rv.ret.devices.devices_len + 1));
  rv.ret.devices.devices_val[rv.ret.devices.devices_len] = NULL;
  return rv.ret.devices.devices_val;
}

struct list_partitions_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_list_partitions_ret ret;
};

static void list_partitions_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct list_partitions_rv *rv = (struct list_partitions_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_list_partitions: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_list_partitions: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_list_partitions_ret (xdr, &rv->ret)) {
    error (g, "guestfs_list_partitions: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_list_partitions (guestfs_h *g)
{
  struct list_partitions_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_list_partitions called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_LIST_PARTITIONS, NULL, NULL);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = list_partitions_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_list_partitions failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_LIST_PARTITIONS, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.partitions.partitions_val =    safe_realloc (g, rv.ret.partitions.partitions_val,
                  sizeof (char *) * (rv.ret.partitions.partitions_len + 1));
  rv.ret.partitions.partitions_val[rv.ret.partitions.partitions_len] = NULL;
  return rv.ret.partitions.partitions_val;
}

struct pvs_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_pvs_ret ret;
};

static void pvs_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct pvs_rv *rv = (struct pvs_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_pvs: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_pvs: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_pvs_ret (xdr, &rv->ret)) {
    error (g, "guestfs_pvs: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_pvs (guestfs_h *g)
{
  struct pvs_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_pvs called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_PVS, NULL, NULL);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = pvs_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_pvs failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_PVS, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.physvols.physvols_val =    safe_realloc (g, rv.ret.physvols.physvols_val,
                  sizeof (char *) * (rv.ret.physvols.physvols_len + 1));
  rv.ret.physvols.physvols_val[rv.ret.physvols.physvols_len] = NULL;
  return rv.ret.physvols.physvols_val;
}

struct vgs_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_vgs_ret ret;
};

static void vgs_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct vgs_rv *rv = (struct vgs_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_vgs: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_vgs: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_vgs_ret (xdr, &rv->ret)) {
    error (g, "guestfs_vgs: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_vgs (guestfs_h *g)
{
  struct vgs_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_vgs called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_VGS, NULL, NULL);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = vgs_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_vgs failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_VGS, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.volgroups.volgroups_val =    safe_realloc (g, rv.ret.volgroups.volgroups_val,
                  sizeof (char *) * (rv.ret.volgroups.volgroups_len + 1));
  rv.ret.volgroups.volgroups_val[rv.ret.volgroups.volgroups_len] = NULL;
  return rv.ret.volgroups.volgroups_val;
}

struct lvs_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_lvs_ret ret;
};

static void lvs_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct lvs_rv *rv = (struct lvs_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_lvs: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_lvs: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_lvs_ret (xdr, &rv->ret)) {
    error (g, "guestfs_lvs: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_lvs (guestfs_h *g)
{
  struct lvs_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_lvs called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_LVS, NULL, NULL);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = lvs_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_lvs failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_LVS, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.logvols.logvols_val =    safe_realloc (g, rv.ret.logvols.logvols_val,
                  sizeof (char *) * (rv.ret.logvols.logvols_len + 1));
  rv.ret.logvols.logvols_val[rv.ret.logvols.logvols_len] = NULL;
  return rv.ret.logvols.logvols_val;
}

struct pvs_full_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_pvs_full_ret ret;
};

static void pvs_full_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct pvs_full_rv *rv = (struct pvs_full_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_pvs_full: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_pvs_full: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_pvs_full_ret (xdr, &rv->ret)) {
    error (g, "guestfs_pvs_full: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

struct guestfs_lvm_pv_list *guestfs_pvs_full (guestfs_h *g)
{
  struct pvs_full_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_pvs_full called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_PVS_FULL, NULL, NULL);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = pvs_full_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_pvs_full failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_PVS_FULL, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this */
  return safe_memdup (g, &rv.ret.physvols, sizeof (rv.ret.physvols));
}

struct vgs_full_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_vgs_full_ret ret;
};

static void vgs_full_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct vgs_full_rv *rv = (struct vgs_full_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_vgs_full: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_vgs_full: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_vgs_full_ret (xdr, &rv->ret)) {
    error (g, "guestfs_vgs_full: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

struct guestfs_lvm_vg_list *guestfs_vgs_full (guestfs_h *g)
{
  struct vgs_full_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_vgs_full called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_VGS_FULL, NULL, NULL);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = vgs_full_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_vgs_full failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_VGS_FULL, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this */
  return safe_memdup (g, &rv.ret.volgroups, sizeof (rv.ret.volgroups));
}

struct lvs_full_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_lvs_full_ret ret;
};

static void lvs_full_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct lvs_full_rv *rv = (struct lvs_full_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_lvs_full: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_lvs_full: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_lvs_full_ret (xdr, &rv->ret)) {
    error (g, "guestfs_lvs_full: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

struct guestfs_lvm_lv_list *guestfs_lvs_full (guestfs_h *g)
{
  struct lvs_full_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_lvs_full called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_LVS_FULL, NULL, NULL);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = lvs_full_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_lvs_full failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_LVS_FULL, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this */
  return safe_memdup (g, &rv.ret.logvols, sizeof (rv.ret.logvols));
}

struct read_lines_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_read_lines_ret ret;
};

static void read_lines_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct read_lines_rv *rv = (struct read_lines_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_read_lines: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_read_lines: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_read_lines_ret (xdr, &rv->ret)) {
    error (g, "guestfs_read_lines: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_read_lines (guestfs_h *g,
		const char *path)
{
  struct guestfs_read_lines_args args;
  struct read_lines_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_read_lines called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_READ_LINES,
                     (xdrproc_t) xdr_guestfs_read_lines_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = read_lines_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_read_lines failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_READ_LINES, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.lines.lines_val =    safe_realloc (g, rv.ret.lines.lines_val,
                  sizeof (char *) * (rv.ret.lines.lines_len + 1));
  rv.ret.lines.lines_val[rv.ret.lines.lines_len] = NULL;
  return rv.ret.lines.lines_val;
}

struct aug_init_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_init_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_init_rv *rv = (struct aug_init_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_init: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_init: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_init (guestfs_h *g,
		const char *root,
		int flags)
{
  struct guestfs_aug_init_args args;
  struct aug_init_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_init called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.root = (char *) root;
  args.flags = flags;
  serial = dispatch (g, GUESTFS_PROC_AUG_INIT,
                     (xdrproc_t) xdr_guestfs_aug_init_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_init_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_init failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_INIT, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct aug_close_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_close_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_close_rv *rv = (struct aug_close_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_close: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_close: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_close (guestfs_h *g)
{
  struct aug_close_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_close called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_AUG_CLOSE, NULL, NULL);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_close_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_close failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_CLOSE, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct aug_defvar_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_defvar_ret ret;
};

static void aug_defvar_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_defvar_rv *rv = (struct aug_defvar_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_defvar: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_defvar: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_defvar_ret (xdr, &rv->ret)) {
    error (g, "guestfs_aug_defvar: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_defvar (guestfs_h *g,
		const char *name,
		const char *expr)
{
  struct guestfs_aug_defvar_args args;
  struct aug_defvar_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_defvar called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.name = (char *) name;
  args.expr = expr ? (char **) &expr : NULL;
  serial = dispatch (g, GUESTFS_PROC_AUG_DEFVAR,
                     (xdrproc_t) xdr_guestfs_aug_defvar_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_defvar_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_defvar failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_DEFVAR, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return rv.ret.nrnodes;
}

struct aug_defnode_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_defnode_ret ret;
};

static void aug_defnode_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_defnode_rv *rv = (struct aug_defnode_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_defnode: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_defnode: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_defnode_ret (xdr, &rv->ret)) {
    error (g, "guestfs_aug_defnode: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

struct guestfs_int_bool *guestfs_aug_defnode (guestfs_h *g,
		const char *name,
		const char *expr,
		const char *val)
{
  struct guestfs_aug_defnode_args args;
  struct aug_defnode_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_defnode called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.name = (char *) name;
  args.expr = (char *) expr;
  args.val = (char *) val;
  serial = dispatch (g, GUESTFS_PROC_AUG_DEFNODE,
                     (xdrproc_t) xdr_guestfs_aug_defnode_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_defnode_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_defnode failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_DEFNODE, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller with free this */
  return safe_memdup (g, &rv.ret, sizeof (rv.ret));
}

struct aug_get_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_get_ret ret;
};

static void aug_get_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_get_rv *rv = (struct aug_get_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_get: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_get: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_get_ret (xdr, &rv->ret)) {
    error (g, "guestfs_aug_get: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char *guestfs_aug_get (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_get_args args;
  struct aug_get_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_get called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_AUG_GET,
                     (xdrproc_t) xdr_guestfs_aug_get_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_get_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_get failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_GET, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  return rv.ret.val; /* caller will free */
}

struct aug_set_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_set_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_set_rv *rv = (struct aug_set_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_set: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_set: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_set (guestfs_h *g,
		const char *path,
		const char *val)
{
  struct guestfs_aug_set_args args;
  struct aug_set_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_set called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  args.val = (char *) val;
  serial = dispatch (g, GUESTFS_PROC_AUG_SET,
                     (xdrproc_t) xdr_guestfs_aug_set_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_set_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_set failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_SET, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct aug_insert_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_insert_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_insert_rv *rv = (struct aug_insert_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_insert: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_insert: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_insert (guestfs_h *g,
		const char *path,
		const char *label,
		int before)
{
  struct guestfs_aug_insert_args args;
  struct aug_insert_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_insert called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  args.label = (char *) label;
  args.before = before;
  serial = dispatch (g, GUESTFS_PROC_AUG_INSERT,
                     (xdrproc_t) xdr_guestfs_aug_insert_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_insert_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_insert failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_INSERT, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct aug_rm_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_rm_ret ret;
};

static void aug_rm_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_rm_rv *rv = (struct aug_rm_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_rm: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_rm: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_rm_ret (xdr, &rv->ret)) {
    error (g, "guestfs_aug_rm: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_rm (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_rm_args args;
  struct aug_rm_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_rm called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_AUG_RM,
                     (xdrproc_t) xdr_guestfs_aug_rm_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_rm_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_rm failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_RM, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return rv.ret.nrnodes;
}

struct aug_mv_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_mv_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_mv_rv *rv = (struct aug_mv_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_mv: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_mv: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_mv (guestfs_h *g,
		const char *src,
		const char *dest)
{
  struct guestfs_aug_mv_args args;
  struct aug_mv_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_mv called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.src = (char *) src;
  args.dest = (char *) dest;
  serial = dispatch (g, GUESTFS_PROC_AUG_MV,
                     (xdrproc_t) xdr_guestfs_aug_mv_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_mv_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_mv failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_MV, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct aug_match_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_match_ret ret;
};

static void aug_match_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_match_rv *rv = (struct aug_match_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_match: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_match: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_match_ret (xdr, &rv->ret)) {
    error (g, "guestfs_aug_match: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_aug_match (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_match_args args;
  struct aug_match_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_match called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_AUG_MATCH,
                     (xdrproc_t) xdr_guestfs_aug_match_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_match_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_match failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_MATCH, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.matches.matches_val =    safe_realloc (g, rv.ret.matches.matches_val,
                  sizeof (char *) * (rv.ret.matches.matches_len + 1));
  rv.ret.matches.matches_val[rv.ret.matches.matches_len] = NULL;
  return rv.ret.matches.matches_val;
}

struct aug_save_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_save_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_save_rv *rv = (struct aug_save_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_save: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_save: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_save (guestfs_h *g)
{
  struct aug_save_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_save called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_AUG_SAVE, NULL, NULL);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_save_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_save failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_SAVE, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct aug_load_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_load_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_load_rv *rv = (struct aug_load_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_load: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_load: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_aug_load (guestfs_h *g)
{
  struct aug_load_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_load called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_AUG_LOAD, NULL, NULL);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_load_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_load failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_LOAD, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct aug_ls_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_ls_ret ret;
};

static void aug_ls_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct aug_ls_rv *rv = (struct aug_ls_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_aug_ls: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_aug_ls: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_ls_ret (xdr, &rv->ret)) {
    error (g, "guestfs_aug_ls: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_aug_ls (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_ls_args args;
  struct aug_ls_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_aug_ls called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_AUG_LS,
                     (xdrproc_t) xdr_guestfs_aug_ls_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = aug_ls_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_aug_ls failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_AUG_LS, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.matches.matches_val =    safe_realloc (g, rv.ret.matches.matches_val,
                  sizeof (char *) * (rv.ret.matches.matches_len + 1));
  rv.ret.matches.matches_val[rv.ret.matches.matches_len] = NULL;
  return rv.ret.matches.matches_val;
}

struct rm_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void rm_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct rm_rv *rv = (struct rm_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_rm: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_rm: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_rm (guestfs_h *g,
		const char *path)
{
  struct guestfs_rm_args args;
  struct rm_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_rm called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_RM,
                     (xdrproc_t) xdr_guestfs_rm_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = rm_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_rm failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_RM, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct rmdir_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void rmdir_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct rmdir_rv *rv = (struct rmdir_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_rmdir: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_rmdir: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_rmdir (guestfs_h *g,
		const char *path)
{
  struct guestfs_rmdir_args args;
  struct rmdir_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_rmdir called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_RMDIR,
                     (xdrproc_t) xdr_guestfs_rmdir_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = rmdir_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_rmdir failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_RMDIR, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct rm_rf_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void rm_rf_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct rm_rf_rv *rv = (struct rm_rf_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_rm_rf: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_rm_rf: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_rm_rf (guestfs_h *g,
		const char *path)
{
  struct guestfs_rm_rf_args args;
  struct rm_rf_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_rm_rf called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_RM_RF,
                     (xdrproc_t) xdr_guestfs_rm_rf_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = rm_rf_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_rm_rf failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_RM_RF, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct mkdir_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mkdir_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct mkdir_rv *rv = (struct mkdir_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_mkdir: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_mkdir: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_mkdir (guestfs_h *g,
		const char *path)
{
  struct guestfs_mkdir_args args;
  struct mkdir_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_mkdir called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_MKDIR,
                     (xdrproc_t) xdr_guestfs_mkdir_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = mkdir_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_mkdir failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_MKDIR, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct mkdir_p_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mkdir_p_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct mkdir_p_rv *rv = (struct mkdir_p_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_mkdir_p: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_mkdir_p: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_mkdir_p (guestfs_h *g,
		const char *path)
{
  struct guestfs_mkdir_p_args args;
  struct mkdir_p_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_mkdir_p called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_MKDIR_P,
                     (xdrproc_t) xdr_guestfs_mkdir_p_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = mkdir_p_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_mkdir_p failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_MKDIR_P, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct chmod_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void chmod_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct chmod_rv *rv = (struct chmod_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_chmod: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_chmod: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_chmod (guestfs_h *g,
		int mode,
		const char *path)
{
  struct guestfs_chmod_args args;
  struct chmod_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_chmod called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.mode = mode;
  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_CHMOD,
                     (xdrproc_t) xdr_guestfs_chmod_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = chmod_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_chmod failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_CHMOD, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct chown_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void chown_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct chown_rv *rv = (struct chown_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_chown: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_chown: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_chown (guestfs_h *g,
		int owner,
		int group,
		const char *path)
{
  struct guestfs_chown_args args;
  struct chown_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_chown called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.owner = owner;
  args.group = group;
  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_CHOWN,
                     (xdrproc_t) xdr_guestfs_chown_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = chown_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_chown failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_CHOWN, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct exists_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_exists_ret ret;
};

static void exists_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct exists_rv *rv = (struct exists_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_exists: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_exists: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_exists_ret (xdr, &rv->ret)) {
    error (g, "guestfs_exists: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_exists (guestfs_h *g,
		const char *path)
{
  struct guestfs_exists_args args;
  struct exists_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_exists called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_EXISTS,
                     (xdrproc_t) xdr_guestfs_exists_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = exists_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_exists failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_EXISTS, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return rv.ret.existsflag;
}

struct is_file_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_is_file_ret ret;
};

static void is_file_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct is_file_rv *rv = (struct is_file_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_is_file: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_is_file: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_is_file_ret (xdr, &rv->ret)) {
    error (g, "guestfs_is_file: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_is_file (guestfs_h *g,
		const char *path)
{
  struct guestfs_is_file_args args;
  struct is_file_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_is_file called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_IS_FILE,
                     (xdrproc_t) xdr_guestfs_is_file_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = is_file_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_is_file failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_IS_FILE, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return rv.ret.fileflag;
}

struct is_dir_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_is_dir_ret ret;
};

static void is_dir_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct is_dir_rv *rv = (struct is_dir_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_is_dir: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_is_dir: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_is_dir_ret (xdr, &rv->ret)) {
    error (g, "guestfs_is_dir: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_is_dir (guestfs_h *g,
		const char *path)
{
  struct guestfs_is_dir_args args;
  struct is_dir_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_is_dir called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_IS_DIR,
                     (xdrproc_t) xdr_guestfs_is_dir_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = is_dir_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_is_dir failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_IS_DIR, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return rv.ret.dirflag;
}

struct pvcreate_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void pvcreate_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct pvcreate_rv *rv = (struct pvcreate_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_pvcreate: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_pvcreate: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_pvcreate (guestfs_h *g,
		const char *device)
{
  struct guestfs_pvcreate_args args;
  struct pvcreate_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_pvcreate called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.device = (char *) device;
  serial = dispatch (g, GUESTFS_PROC_PVCREATE,
                     (xdrproc_t) xdr_guestfs_pvcreate_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = pvcreate_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_pvcreate failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_PVCREATE, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct vgcreate_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void vgcreate_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct vgcreate_rv *rv = (struct vgcreate_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_vgcreate: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_vgcreate: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_vgcreate (guestfs_h *g,
		const char *volgroup,
		char * const* const physvols)
{
  struct guestfs_vgcreate_args args;
  struct vgcreate_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_vgcreate called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.volgroup = (char *) volgroup;
  args.physvols.physvols_val = (char **) physvols;
  for (args.physvols.physvols_len = 0; physvols[args.physvols.physvols_len]; args.physvols.physvols_len++) ;
  serial = dispatch (g, GUESTFS_PROC_VGCREATE,
                     (xdrproc_t) xdr_guestfs_vgcreate_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = vgcreate_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_vgcreate failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_VGCREATE, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct lvcreate_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void lvcreate_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct lvcreate_rv *rv = (struct lvcreate_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_lvcreate: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_lvcreate: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_lvcreate (guestfs_h *g,
		const char *logvol,
		const char *volgroup,
		int mbytes)
{
  struct guestfs_lvcreate_args args;
  struct lvcreate_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_lvcreate called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.logvol = (char *) logvol;
  args.volgroup = (char *) volgroup;
  args.mbytes = mbytes;
  serial = dispatch (g, GUESTFS_PROC_LVCREATE,
                     (xdrproc_t) xdr_guestfs_lvcreate_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = lvcreate_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_lvcreate failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_LVCREATE, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct mkfs_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mkfs_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct mkfs_rv *rv = (struct mkfs_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_mkfs: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_mkfs: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_mkfs (guestfs_h *g,
		const char *fstype,
		const char *device)
{
  struct guestfs_mkfs_args args;
  struct mkfs_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_mkfs called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.fstype = (char *) fstype;
  args.device = (char *) device;
  serial = dispatch (g, GUESTFS_PROC_MKFS,
                     (xdrproc_t) xdr_guestfs_mkfs_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = mkfs_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_mkfs failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_MKFS, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct sfdisk_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void sfdisk_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct sfdisk_rv *rv = (struct sfdisk_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_sfdisk: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_sfdisk: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_sfdisk (guestfs_h *g,
		const char *device,
		int cyls,
		int heads,
		int sectors,
		char * const* const lines)
{
  struct guestfs_sfdisk_args args;
  struct sfdisk_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_sfdisk called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.device = (char *) device;
  args.cyls = cyls;
  args.heads = heads;
  args.sectors = sectors;
  args.lines.lines_val = (char **) lines;
  for (args.lines.lines_len = 0; lines[args.lines.lines_len]; args.lines.lines_len++) ;
  serial = dispatch (g, GUESTFS_PROC_SFDISK,
                     (xdrproc_t) xdr_guestfs_sfdisk_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = sfdisk_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_sfdisk failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_SFDISK, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct write_file_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void write_file_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct write_file_rv *rv = (struct write_file_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_write_file: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_write_file: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_write_file (guestfs_h *g,
		const char *path,
		const char *content,
		int size)
{
  struct guestfs_write_file_args args;
  struct write_file_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_write_file called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  args.content = (char *) content;
  args.size = size;
  serial = dispatch (g, GUESTFS_PROC_WRITE_FILE,
                     (xdrproc_t) xdr_guestfs_write_file_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = write_file_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_write_file failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_WRITE_FILE, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct umount_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void umount_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct umount_rv *rv = (struct umount_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_umount: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_umount: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_umount (guestfs_h *g,
		const char *pathordevice)
{
  struct guestfs_umount_args args;
  struct umount_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_umount called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  args.pathordevice = (char *) pathordevice;
  serial = dispatch (g, GUESTFS_PROC_UMOUNT,
                     (xdrproc_t) xdr_guestfs_umount_args, (char *) &args);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = umount_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_umount failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_UMOUNT, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct mounts_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_mounts_ret ret;
};

static void mounts_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct mounts_rv *rv = (struct mounts_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_mounts: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_mounts: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_mounts_ret (xdr, &rv->ret)) {
    error (g, "guestfs_mounts: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_mounts (guestfs_h *g)
{
  struct mounts_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_mounts called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_MOUNTS, NULL, NULL);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = mounts_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_mounts failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_MOUNTS, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.devices.devices_val =    safe_realloc (g, rv.ret.devices.devices_val,
                  sizeof (char *) * (rv.ret.devices.devices_len + 1));
  rv.ret.devices.devices_val[rv.ret.devices.devices_len] = NULL;
  return rv.ret.devices.devices_val;
}

struct umount_all_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void umount_all_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct umount_all_rv *rv = (struct umount_all_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_umount_all: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_umount_all: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_umount_all (guestfs_h *g)
{
  struct umount_all_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_umount_all called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_UMOUNT_ALL, NULL, NULL);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = umount_all_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_umount_all failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_UMOUNT_ALL, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct lvm_remove_all_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void lvm_remove_all_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct lvm_remove_all_rv *rv = (struct lvm_remove_all_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_lvm_remove_all: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_lvm_remove_all: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

int guestfs_lvm_remove_all (guestfs_h *g)
{
  struct lvm_remove_all_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_lvm_remove_all called from the wrong state, %d != READY",
      g->state);
    return -1;
  }

  memset (&rv, 0, sizeof rv);

  serial = dispatch (g, GUESTFS_PROC_LVM_REMOVE_ALL, NULL, NULL);
  if (serial == -1)
    return -1;

  rv.cb_done = 0;
  g->reply_cb_internal = lvm_remove_all_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_lvm_remove_all failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_LVM_REMOVE_ALL, serial) == -1)
    return -1;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return -1;
  }

  return 0;
}

struct file_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_file_ret ret;
};

static void file_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct file_rv *rv = (struct file_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_file: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_file: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_file_ret (xdr, &rv->ret)) {
    error (g, "guestfs_file: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char *guestfs_file (guestfs_h *g,
		const char *path)
{
  struct guestfs_file_args args;
  struct file_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_file called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.path = (char *) path;
  serial = dispatch (g, GUESTFS_PROC_FILE,
                     (xdrproc_t) xdr_guestfs_file_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = file_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_file failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_FILE, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  return rv.ret.description; /* caller will free */
}

struct command_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_command_ret ret;
};

static void command_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct command_rv *rv = (struct command_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_command: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_command: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_command_ret (xdr, &rv->ret)) {
    error (g, "guestfs_command: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char *guestfs_command (guestfs_h *g,
		char * const* const arguments)
{
  struct guestfs_command_args args;
  struct command_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_command called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.arguments.arguments_val = (char **) arguments;
  for (args.arguments.arguments_len = 0; arguments[args.arguments.arguments_len]; args.arguments.arguments_len++) ;
  serial = dispatch (g, GUESTFS_PROC_COMMAND,
                     (xdrproc_t) xdr_guestfs_command_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = command_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_command failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_COMMAND, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  return rv.ret.output; /* caller will free */
}

struct command_lines_rv {
  int cb_done;  /* flag to indicate callback was called */
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_command_lines_ret ret;
};

static void command_lines_cb (guestfs_h *g, void *data, XDR *xdr)
{
  struct command_lines_rv *rv = (struct command_lines_rv *) data;

  if (!xdr_guestfs_message_header (xdr, &rv->hdr)) {
    error (g, "guestfs_command_lines: failed to parse reply header");
    return;
  }
  if (rv->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &rv->err)) {
      error (g, "guestfs_command_lines: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_command_lines_ret (xdr, &rv->ret)) {
    error (g, "guestfs_command_lines: failed to parse reply");
    return;
  }
 done:
  rv->cb_done = 1;
  main_loop.main_loop_quit (g);
}

char **guestfs_command_lines (guestfs_h *g,
		char * const* const arguments)
{
  struct guestfs_command_lines_args args;
  struct command_lines_rv rv;
  int serial;

  if (g->state != READY) {
    error (g, "guestfs_command_lines called from the wrong state, %d != READY",
      g->state);
    return NULL;
  }

  memset (&rv, 0, sizeof rv);

  args.arguments.arguments_val = (char **) arguments;
  for (args.arguments.arguments_len = 0; arguments[args.arguments.arguments_len]; args.arguments.arguments_len++) ;
  serial = dispatch (g, GUESTFS_PROC_COMMAND_LINES,
                     (xdrproc_t) xdr_guestfs_command_lines_args, (char *) &args);
  if (serial == -1)
    return NULL;

  rv.cb_done = 0;
  g->reply_cb_internal = command_lines_cb;
  g->reply_cb_internal_data = &rv;
  main_loop.main_loop_run (g);
  g->reply_cb_internal = NULL;
  g->reply_cb_internal_data = NULL;
  if (!rv.cb_done) {
    error (g, "guestfs_command_lines failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &rv.hdr, GUESTFS_PROC_COMMAND_LINES, serial) == -1)
    return NULL;

  if (rv.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", rv.err.error);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  rv.ret.lines.lines_val =    safe_realloc (g, rv.ret.lines.lines_val,
                  sizeof (char *) * (rv.ret.lines.lines_len + 1));
  rv.ret.lines.lines_val[rv.ret.lines.lines_len] = NULL;
  return rv.ret.lines.lines_val;
}

