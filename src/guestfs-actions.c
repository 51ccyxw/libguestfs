/* libguestfs generated file
 * WARNING: THIS FILE IS GENERATED BY 'src/generator.ml'.
 * ANY CHANGES YOU MAKE TO THIS FILE WILL BE LOST.
 *
 * Copyright (C) 2009 Red Hat Inc.
 *
 * This library is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Lesser General Public
 * License as published by the Free Software Foundation; either
 * version 2 of the License, or (at your option) any later version.
 *
 * This library is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public
 * License along with this library; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
 */

#include <stdio.h>
#include <stdlib.h>

#include "guestfs.h"
#include "guestfs_protocol.h"

#define error guestfs_error
#define perrorf guestfs_perrorf
#define safe_malloc guestfs_safe_malloc
#define safe_realloc guestfs_safe_realloc
#define safe_strdup guestfs_safe_strdup
#define safe_memdup guestfs_safe_memdup

/* Check the return message from a call for validity. */
static int
check_reply_header (guestfs_h *g,
                    const struct guestfs_message_header *hdr,
                    int proc_nr, int serial)
{
  if (hdr->prog != GUESTFS_PROGRAM) {
    error (g, "wrong program (%d/%d)", hdr->prog, GUESTFS_PROGRAM);
    return -1;
  }
  if (hdr->vers != GUESTFS_PROTOCOL_VERSION) {
    error (g, "wrong protocol version (%d/%d)",
	   hdr->vers, GUESTFS_PROTOCOL_VERSION);
    return -1;
  }
  if (hdr->direction != GUESTFS_DIRECTION_REPLY) {
    error (g, "unexpected message direction (%d/%d)",
	   hdr->direction, GUESTFS_DIRECTION_REPLY);
    return -1;
  }
  if (hdr->proc != proc_nr) {
    error (g, "unexpected procedure number (%d/%d)", hdr->proc, proc_nr);
    return -1;
  }
  if (hdr->serial != serial) {
    error (g, "unexpected serial (%d/%d)", hdr->serial, serial);
    return -1;
  }

  return 0;
}

/* Check we are in the right state to run a high-level action. */
static int
check_state (guestfs_h *g, const char *caller)
{
  if (!guestfs_is_ready (g)) {
    if (guestfs_is_config (g))
      error (g, "%s: call launch() before using this function",
        caller);
    else if (guestfs_is_launching (g))
      error (g, "%s: call wait_ready() before using this function",
        caller);
    else
      error (g, "%s called from the wrong state, %d != READY",
        caller, guestfs_get_state (g));
    return -1;
  }
  return 0;
}

struct mount_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mount_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mount_state *state = (struct mount_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_mount: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_mount: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_mount (guestfs_h *g,
		const char *device,
		const char *mountpoint)
{
  struct guestfs_mount_args args;
  struct mount_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mount") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.device = (char *) device;
  args.mountpoint = (char *) mountpoint;
  serial = guestfs__send (g, GUESTFS_PROC_MOUNT,
                     (xdrproc_t) xdr_guestfs_mount_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, mount_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_mount failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_MOUNT, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct sync_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void sync_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct sync_state *state = (struct sync_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_sync: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_sync: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_sync (guestfs_h *g)
{
  struct sync_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_sync") == -1) return -1;

  memset (&state, 0, sizeof state);

  serial = guestfs__send (g, GUESTFS_PROC_SYNC, NULL, NULL);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, sync_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_sync failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_SYNC, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct touch_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void touch_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct touch_state *state = (struct touch_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_touch: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_touch: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_touch (guestfs_h *g,
		const char *path)
{
  struct guestfs_touch_args args;
  struct touch_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_touch") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_TOUCH,
                     (xdrproc_t) xdr_guestfs_touch_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, touch_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_touch failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_TOUCH, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct cat_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_cat_ret ret;
};

static void cat_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct cat_state *state = (struct cat_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_cat: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_cat: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_cat_ret (xdr, &state->ret)) {
    error (g, "guestfs_cat: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

char *guestfs_cat (guestfs_h *g,
		const char *path)
{
  struct guestfs_cat_args args;
  struct cat_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_cat") == -1) return NULL;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_CAT,
                     (xdrproc_t) xdr_guestfs_cat_args, (char *) &args);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, cat_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_cat failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_CAT, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  return state.ret.content; /* caller will free */
}

struct ll_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_ll_ret ret;
};

static void ll_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct ll_state *state = (struct ll_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_ll: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_ll: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_ll_ret (xdr, &state->ret)) {
    error (g, "guestfs_ll: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

char *guestfs_ll (guestfs_h *g,
		const char *directory)
{
  struct guestfs_ll_args args;
  struct ll_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_ll") == -1) return NULL;

  memset (&state, 0, sizeof state);

  args.directory = (char *) directory;
  serial = guestfs__send (g, GUESTFS_PROC_LL,
                     (xdrproc_t) xdr_guestfs_ll_args, (char *) &args);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, ll_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_ll failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_LL, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  return state.ret.listing; /* caller will free */
}

struct ls_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_ls_ret ret;
};

static void ls_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct ls_state *state = (struct ls_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_ls: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_ls: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_ls_ret (xdr, &state->ret)) {
    error (g, "guestfs_ls: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

char **guestfs_ls (guestfs_h *g,
		const char *directory)
{
  struct guestfs_ls_args args;
  struct ls_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_ls") == -1) return NULL;

  memset (&state, 0, sizeof state);

  args.directory = (char *) directory;
  serial = guestfs__send (g, GUESTFS_PROC_LS,
                     (xdrproc_t) xdr_guestfs_ls_args, (char *) &args);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, ls_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_ls failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_LS, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  state.ret.listing.listing_val =
    safe_realloc (g, state.ret.listing.listing_val,
                  sizeof (char *) * (state.ret.listing.listing_len + 1));
  state.ret.listing.listing_val[state.ret.listing.listing_len] = NULL;
  return state.ret.listing.listing_val;
}

struct list_devices_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_list_devices_ret ret;
};

static void list_devices_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct list_devices_state *state = (struct list_devices_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_list_devices: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_list_devices: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_list_devices_ret (xdr, &state->ret)) {
    error (g, "guestfs_list_devices: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

char **guestfs_list_devices (guestfs_h *g)
{
  struct list_devices_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_list_devices") == -1) return NULL;

  memset (&state, 0, sizeof state);

  serial = guestfs__send (g, GUESTFS_PROC_LIST_DEVICES, NULL, NULL);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, list_devices_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_list_devices failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_LIST_DEVICES, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  state.ret.devices.devices_val =
    safe_realloc (g, state.ret.devices.devices_val,
                  sizeof (char *) * (state.ret.devices.devices_len + 1));
  state.ret.devices.devices_val[state.ret.devices.devices_len] = NULL;
  return state.ret.devices.devices_val;
}

struct list_partitions_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_list_partitions_ret ret;
};

static void list_partitions_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct list_partitions_state *state = (struct list_partitions_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_list_partitions: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_list_partitions: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_list_partitions_ret (xdr, &state->ret)) {
    error (g, "guestfs_list_partitions: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

char **guestfs_list_partitions (guestfs_h *g)
{
  struct list_partitions_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_list_partitions") == -1) return NULL;

  memset (&state, 0, sizeof state);

  serial = guestfs__send (g, GUESTFS_PROC_LIST_PARTITIONS, NULL, NULL);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, list_partitions_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_list_partitions failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_LIST_PARTITIONS, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  state.ret.partitions.partitions_val =
    safe_realloc (g, state.ret.partitions.partitions_val,
                  sizeof (char *) * (state.ret.partitions.partitions_len + 1));
  state.ret.partitions.partitions_val[state.ret.partitions.partitions_len] = NULL;
  return state.ret.partitions.partitions_val;
}

struct pvs_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_pvs_ret ret;
};

static void pvs_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct pvs_state *state = (struct pvs_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_pvs: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_pvs: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_pvs_ret (xdr, &state->ret)) {
    error (g, "guestfs_pvs: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

char **guestfs_pvs (guestfs_h *g)
{
  struct pvs_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_pvs") == -1) return NULL;

  memset (&state, 0, sizeof state);

  serial = guestfs__send (g, GUESTFS_PROC_PVS, NULL, NULL);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, pvs_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_pvs failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_PVS, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  state.ret.physvols.physvols_val =
    safe_realloc (g, state.ret.physvols.physvols_val,
                  sizeof (char *) * (state.ret.physvols.physvols_len + 1));
  state.ret.physvols.physvols_val[state.ret.physvols.physvols_len] = NULL;
  return state.ret.physvols.physvols_val;
}

struct vgs_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_vgs_ret ret;
};

static void vgs_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct vgs_state *state = (struct vgs_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_vgs: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_vgs: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_vgs_ret (xdr, &state->ret)) {
    error (g, "guestfs_vgs: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

char **guestfs_vgs (guestfs_h *g)
{
  struct vgs_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_vgs") == -1) return NULL;

  memset (&state, 0, sizeof state);

  serial = guestfs__send (g, GUESTFS_PROC_VGS, NULL, NULL);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, vgs_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_vgs failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_VGS, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  state.ret.volgroups.volgroups_val =
    safe_realloc (g, state.ret.volgroups.volgroups_val,
                  sizeof (char *) * (state.ret.volgroups.volgroups_len + 1));
  state.ret.volgroups.volgroups_val[state.ret.volgroups.volgroups_len] = NULL;
  return state.ret.volgroups.volgroups_val;
}

struct lvs_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_lvs_ret ret;
};

static void lvs_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lvs_state *state = (struct lvs_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_lvs: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_lvs: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_lvs_ret (xdr, &state->ret)) {
    error (g, "guestfs_lvs: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

char **guestfs_lvs (guestfs_h *g)
{
  struct lvs_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lvs") == -1) return NULL;

  memset (&state, 0, sizeof state);

  serial = guestfs__send (g, GUESTFS_PROC_LVS, NULL, NULL);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, lvs_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_lvs failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_LVS, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  state.ret.logvols.logvols_val =
    safe_realloc (g, state.ret.logvols.logvols_val,
                  sizeof (char *) * (state.ret.logvols.logvols_len + 1));
  state.ret.logvols.logvols_val[state.ret.logvols.logvols_len] = NULL;
  return state.ret.logvols.logvols_val;
}

struct pvs_full_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_pvs_full_ret ret;
};

static void pvs_full_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct pvs_full_state *state = (struct pvs_full_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_pvs_full: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_pvs_full: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_pvs_full_ret (xdr, &state->ret)) {
    error (g, "guestfs_pvs_full: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

struct guestfs_lvm_pv_list *guestfs_pvs_full (guestfs_h *g)
{
  struct pvs_full_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_pvs_full") == -1) return NULL;

  memset (&state, 0, sizeof state);

  serial = guestfs__send (g, GUESTFS_PROC_PVS_FULL, NULL, NULL);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, pvs_full_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_pvs_full failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_PVS_FULL, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this */
  return safe_memdup (g, &state.ret.physvols, sizeof (state.ret.physvols));
}

struct vgs_full_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_vgs_full_ret ret;
};

static void vgs_full_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct vgs_full_state *state = (struct vgs_full_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_vgs_full: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_vgs_full: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_vgs_full_ret (xdr, &state->ret)) {
    error (g, "guestfs_vgs_full: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

struct guestfs_lvm_vg_list *guestfs_vgs_full (guestfs_h *g)
{
  struct vgs_full_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_vgs_full") == -1) return NULL;

  memset (&state, 0, sizeof state);

  serial = guestfs__send (g, GUESTFS_PROC_VGS_FULL, NULL, NULL);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, vgs_full_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_vgs_full failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_VGS_FULL, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this */
  return safe_memdup (g, &state.ret.volgroups, sizeof (state.ret.volgroups));
}

struct lvs_full_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_lvs_full_ret ret;
};

static void lvs_full_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lvs_full_state *state = (struct lvs_full_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_lvs_full: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_lvs_full: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_lvs_full_ret (xdr, &state->ret)) {
    error (g, "guestfs_lvs_full: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

struct guestfs_lvm_lv_list *guestfs_lvs_full (guestfs_h *g)
{
  struct lvs_full_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lvs_full") == -1) return NULL;

  memset (&state, 0, sizeof state);

  serial = guestfs__send (g, GUESTFS_PROC_LVS_FULL, NULL, NULL);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, lvs_full_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_lvs_full failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_LVS_FULL, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this */
  return safe_memdup (g, &state.ret.logvols, sizeof (state.ret.logvols));
}

struct read_lines_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_read_lines_ret ret;
};

static void read_lines_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct read_lines_state *state = (struct read_lines_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_read_lines: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_read_lines: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_read_lines_ret (xdr, &state->ret)) {
    error (g, "guestfs_read_lines: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

char **guestfs_read_lines (guestfs_h *g,
		const char *path)
{
  struct guestfs_read_lines_args args;
  struct read_lines_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_read_lines") == -1) return NULL;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_READ_LINES,
                     (xdrproc_t) xdr_guestfs_read_lines_args, (char *) &args);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, read_lines_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_read_lines failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_READ_LINES, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  state.ret.lines.lines_val =
    safe_realloc (g, state.ret.lines.lines_val,
                  sizeof (char *) * (state.ret.lines.lines_len + 1));
  state.ret.lines.lines_val[state.ret.lines.lines_len] = NULL;
  return state.ret.lines.lines_val;
}

struct aug_init_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_init_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_init_state *state = (struct aug_init_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_aug_init: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_aug_init: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_aug_init (guestfs_h *g,
		const char *root,
		int flags)
{
  struct guestfs_aug_init_args args;
  struct aug_init_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_init") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.root = (char *) root;
  args.flags = flags;
  serial = guestfs__send (g, GUESTFS_PROC_AUG_INIT,
                     (xdrproc_t) xdr_guestfs_aug_init_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, aug_init_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_aug_init failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_AUG_INIT, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct aug_close_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_close_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_close_state *state = (struct aug_close_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_aug_close: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_aug_close: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_aug_close (guestfs_h *g)
{
  struct aug_close_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_close") == -1) return -1;

  memset (&state, 0, sizeof state);

  serial = guestfs__send (g, GUESTFS_PROC_AUG_CLOSE, NULL, NULL);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, aug_close_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_aug_close failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_AUG_CLOSE, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct aug_defvar_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_defvar_ret ret;
};

static void aug_defvar_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_defvar_state *state = (struct aug_defvar_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_aug_defvar: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_aug_defvar: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_defvar_ret (xdr, &state->ret)) {
    error (g, "guestfs_aug_defvar: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_aug_defvar (guestfs_h *g,
		const char *name,
		const char *expr)
{
  struct guestfs_aug_defvar_args args;
  struct aug_defvar_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_defvar") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.name = (char *) name;
  args.expr = expr ? (char **) &expr : NULL;
  serial = guestfs__send (g, GUESTFS_PROC_AUG_DEFVAR,
                     (xdrproc_t) xdr_guestfs_aug_defvar_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, aug_defvar_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_aug_defvar failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_AUG_DEFVAR, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return state.ret.nrnodes;
}

struct aug_defnode_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_defnode_ret ret;
};

static void aug_defnode_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_defnode_state *state = (struct aug_defnode_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_aug_defnode: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_aug_defnode: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_defnode_ret (xdr, &state->ret)) {
    error (g, "guestfs_aug_defnode: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

struct guestfs_int_bool *guestfs_aug_defnode (guestfs_h *g,
		const char *name,
		const char *expr,
		const char *val)
{
  struct guestfs_aug_defnode_args args;
  struct aug_defnode_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_defnode") == -1) return NULL;

  memset (&state, 0, sizeof state);

  args.name = (char *) name;
  args.expr = (char *) expr;
  args.val = (char *) val;
  serial = guestfs__send (g, GUESTFS_PROC_AUG_DEFNODE,
                     (xdrproc_t) xdr_guestfs_aug_defnode_args, (char *) &args);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, aug_defnode_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_aug_defnode failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_AUG_DEFNODE, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller with free this */
  return safe_memdup (g, &state.ret, sizeof (state.ret));
}

struct aug_get_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_get_ret ret;
};

static void aug_get_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_get_state *state = (struct aug_get_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_aug_get: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_aug_get: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_get_ret (xdr, &state->ret)) {
    error (g, "guestfs_aug_get: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

char *guestfs_aug_get (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_get_args args;
  struct aug_get_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_get") == -1) return NULL;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_AUG_GET,
                     (xdrproc_t) xdr_guestfs_aug_get_args, (char *) &args);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, aug_get_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_aug_get failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_AUG_GET, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  return state.ret.val; /* caller will free */
}

struct aug_set_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_set_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_set_state *state = (struct aug_set_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_aug_set: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_aug_set: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_aug_set (guestfs_h *g,
		const char *path,
		const char *val)
{
  struct guestfs_aug_set_args args;
  struct aug_set_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_set") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  args.val = (char *) val;
  serial = guestfs__send (g, GUESTFS_PROC_AUG_SET,
                     (xdrproc_t) xdr_guestfs_aug_set_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, aug_set_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_aug_set failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_AUG_SET, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct aug_insert_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_insert_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_insert_state *state = (struct aug_insert_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_aug_insert: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_aug_insert: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_aug_insert (guestfs_h *g,
		const char *path,
		const char *label,
		int before)
{
  struct guestfs_aug_insert_args args;
  struct aug_insert_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_insert") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  args.label = (char *) label;
  args.before = before;
  serial = guestfs__send (g, GUESTFS_PROC_AUG_INSERT,
                     (xdrproc_t) xdr_guestfs_aug_insert_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, aug_insert_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_aug_insert failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_AUG_INSERT, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct aug_rm_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_rm_ret ret;
};

static void aug_rm_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_rm_state *state = (struct aug_rm_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_aug_rm: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_aug_rm: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_rm_ret (xdr, &state->ret)) {
    error (g, "guestfs_aug_rm: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_aug_rm (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_rm_args args;
  struct aug_rm_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_rm") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_AUG_RM,
                     (xdrproc_t) xdr_guestfs_aug_rm_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, aug_rm_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_aug_rm failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_AUG_RM, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return state.ret.nrnodes;
}

struct aug_mv_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_mv_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_mv_state *state = (struct aug_mv_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_aug_mv: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_aug_mv: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_aug_mv (guestfs_h *g,
		const char *src,
		const char *dest)
{
  struct guestfs_aug_mv_args args;
  struct aug_mv_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_mv") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.src = (char *) src;
  args.dest = (char *) dest;
  serial = guestfs__send (g, GUESTFS_PROC_AUG_MV,
                     (xdrproc_t) xdr_guestfs_aug_mv_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, aug_mv_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_aug_mv failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_AUG_MV, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct aug_match_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_match_ret ret;
};

static void aug_match_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_match_state *state = (struct aug_match_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_aug_match: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_aug_match: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_match_ret (xdr, &state->ret)) {
    error (g, "guestfs_aug_match: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

char **guestfs_aug_match (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_match_args args;
  struct aug_match_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_match") == -1) return NULL;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_AUG_MATCH,
                     (xdrproc_t) xdr_guestfs_aug_match_args, (char *) &args);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, aug_match_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_aug_match failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_AUG_MATCH, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  state.ret.matches.matches_val =
    safe_realloc (g, state.ret.matches.matches_val,
                  sizeof (char *) * (state.ret.matches.matches_len + 1));
  state.ret.matches.matches_val[state.ret.matches.matches_len] = NULL;
  return state.ret.matches.matches_val;
}

struct aug_save_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_save_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_save_state *state = (struct aug_save_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_aug_save: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_aug_save: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_aug_save (guestfs_h *g)
{
  struct aug_save_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_save") == -1) return -1;

  memset (&state, 0, sizeof state);

  serial = guestfs__send (g, GUESTFS_PROC_AUG_SAVE, NULL, NULL);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, aug_save_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_aug_save failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_AUG_SAVE, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct aug_load_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void aug_load_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_load_state *state = (struct aug_load_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_aug_load: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_aug_load: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_aug_load (guestfs_h *g)
{
  struct aug_load_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_load") == -1) return -1;

  memset (&state, 0, sizeof state);

  serial = guestfs__send (g, GUESTFS_PROC_AUG_LOAD, NULL, NULL);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, aug_load_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_aug_load failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_AUG_LOAD, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct aug_ls_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_aug_ls_ret ret;
};

static void aug_ls_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct aug_ls_state *state = (struct aug_ls_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_aug_ls: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_aug_ls: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_aug_ls_ret (xdr, &state->ret)) {
    error (g, "guestfs_aug_ls: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

char **guestfs_aug_ls (guestfs_h *g,
		const char *path)
{
  struct guestfs_aug_ls_args args;
  struct aug_ls_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_aug_ls") == -1) return NULL;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_AUG_LS,
                     (xdrproc_t) xdr_guestfs_aug_ls_args, (char *) &args);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, aug_ls_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_aug_ls failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_AUG_LS, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  state.ret.matches.matches_val =
    safe_realloc (g, state.ret.matches.matches_val,
                  sizeof (char *) * (state.ret.matches.matches_len + 1));
  state.ret.matches.matches_val[state.ret.matches.matches_len] = NULL;
  return state.ret.matches.matches_val;
}

struct rm_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void rm_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct rm_state *state = (struct rm_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_rm: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_rm: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_rm (guestfs_h *g,
		const char *path)
{
  struct guestfs_rm_args args;
  struct rm_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_rm") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_RM,
                     (xdrproc_t) xdr_guestfs_rm_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, rm_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_rm failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_RM, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct rmdir_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void rmdir_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct rmdir_state *state = (struct rmdir_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_rmdir: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_rmdir: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_rmdir (guestfs_h *g,
		const char *path)
{
  struct guestfs_rmdir_args args;
  struct rmdir_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_rmdir") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_RMDIR,
                     (xdrproc_t) xdr_guestfs_rmdir_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, rmdir_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_rmdir failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_RMDIR, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct rm_rf_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void rm_rf_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct rm_rf_state *state = (struct rm_rf_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_rm_rf: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_rm_rf: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_rm_rf (guestfs_h *g,
		const char *path)
{
  struct guestfs_rm_rf_args args;
  struct rm_rf_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_rm_rf") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_RM_RF,
                     (xdrproc_t) xdr_guestfs_rm_rf_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, rm_rf_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_rm_rf failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_RM_RF, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct mkdir_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mkdir_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mkdir_state *state = (struct mkdir_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_mkdir: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_mkdir: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_mkdir (guestfs_h *g,
		const char *path)
{
  struct guestfs_mkdir_args args;
  struct mkdir_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mkdir") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_MKDIR,
                     (xdrproc_t) xdr_guestfs_mkdir_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, mkdir_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_mkdir failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_MKDIR, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct mkdir_p_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mkdir_p_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mkdir_p_state *state = (struct mkdir_p_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_mkdir_p: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_mkdir_p: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_mkdir_p (guestfs_h *g,
		const char *path)
{
  struct guestfs_mkdir_p_args args;
  struct mkdir_p_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mkdir_p") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_MKDIR_P,
                     (xdrproc_t) xdr_guestfs_mkdir_p_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, mkdir_p_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_mkdir_p failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_MKDIR_P, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct chmod_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void chmod_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct chmod_state *state = (struct chmod_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_chmod: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_chmod: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_chmod (guestfs_h *g,
		int mode,
		const char *path)
{
  struct guestfs_chmod_args args;
  struct chmod_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_chmod") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.mode = mode;
  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_CHMOD,
                     (xdrproc_t) xdr_guestfs_chmod_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, chmod_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_chmod failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_CHMOD, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct chown_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void chown_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct chown_state *state = (struct chown_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_chown: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_chown: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_chown (guestfs_h *g,
		int owner,
		int group,
		const char *path)
{
  struct guestfs_chown_args args;
  struct chown_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_chown") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.owner = owner;
  args.group = group;
  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_CHOWN,
                     (xdrproc_t) xdr_guestfs_chown_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, chown_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_chown failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_CHOWN, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct exists_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_exists_ret ret;
};

static void exists_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct exists_state *state = (struct exists_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_exists: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_exists: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_exists_ret (xdr, &state->ret)) {
    error (g, "guestfs_exists: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_exists (guestfs_h *g,
		const char *path)
{
  struct guestfs_exists_args args;
  struct exists_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_exists") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_EXISTS,
                     (xdrproc_t) xdr_guestfs_exists_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, exists_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_exists failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_EXISTS, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return state.ret.existsflag;
}

struct is_file_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_is_file_ret ret;
};

static void is_file_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct is_file_state *state = (struct is_file_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_is_file: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_is_file: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_is_file_ret (xdr, &state->ret)) {
    error (g, "guestfs_is_file: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_is_file (guestfs_h *g,
		const char *path)
{
  struct guestfs_is_file_args args;
  struct is_file_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_is_file") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_IS_FILE,
                     (xdrproc_t) xdr_guestfs_is_file_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, is_file_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_is_file failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_IS_FILE, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return state.ret.fileflag;
}

struct is_dir_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_is_dir_ret ret;
};

static void is_dir_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct is_dir_state *state = (struct is_dir_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_is_dir: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_is_dir: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_is_dir_ret (xdr, &state->ret)) {
    error (g, "guestfs_is_dir: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_is_dir (guestfs_h *g,
		const char *path)
{
  struct guestfs_is_dir_args args;
  struct is_dir_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_is_dir") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_IS_DIR,
                     (xdrproc_t) xdr_guestfs_is_dir_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, is_dir_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_is_dir failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_IS_DIR, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return state.ret.dirflag;
}

struct pvcreate_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void pvcreate_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct pvcreate_state *state = (struct pvcreate_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_pvcreate: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_pvcreate: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_pvcreate (guestfs_h *g,
		const char *device)
{
  struct guestfs_pvcreate_args args;
  struct pvcreate_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_pvcreate") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.device = (char *) device;
  serial = guestfs__send (g, GUESTFS_PROC_PVCREATE,
                     (xdrproc_t) xdr_guestfs_pvcreate_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, pvcreate_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_pvcreate failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_PVCREATE, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct vgcreate_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void vgcreate_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct vgcreate_state *state = (struct vgcreate_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_vgcreate: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_vgcreate: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_vgcreate (guestfs_h *g,
		const char *volgroup,
		char * const* const physvols)
{
  struct guestfs_vgcreate_args args;
  struct vgcreate_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_vgcreate") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.volgroup = (char *) volgroup;
  args.physvols.physvols_val = (char **) physvols;
  for (args.physvols.physvols_len = 0; physvols[args.physvols.physvols_len]; args.physvols.physvols_len++) ;
  serial = guestfs__send (g, GUESTFS_PROC_VGCREATE,
                     (xdrproc_t) xdr_guestfs_vgcreate_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, vgcreate_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_vgcreate failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_VGCREATE, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct lvcreate_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void lvcreate_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lvcreate_state *state = (struct lvcreate_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_lvcreate: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_lvcreate: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_lvcreate (guestfs_h *g,
		const char *logvol,
		const char *volgroup,
		int mbytes)
{
  struct guestfs_lvcreate_args args;
  struct lvcreate_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lvcreate") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.logvol = (char *) logvol;
  args.volgroup = (char *) volgroup;
  args.mbytes = mbytes;
  serial = guestfs__send (g, GUESTFS_PROC_LVCREATE,
                     (xdrproc_t) xdr_guestfs_lvcreate_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, lvcreate_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_lvcreate failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_LVCREATE, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct mkfs_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void mkfs_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mkfs_state *state = (struct mkfs_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_mkfs: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_mkfs: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_mkfs (guestfs_h *g,
		const char *fstype,
		const char *device)
{
  struct guestfs_mkfs_args args;
  struct mkfs_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mkfs") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.fstype = (char *) fstype;
  args.device = (char *) device;
  serial = guestfs__send (g, GUESTFS_PROC_MKFS,
                     (xdrproc_t) xdr_guestfs_mkfs_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, mkfs_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_mkfs failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_MKFS, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct sfdisk_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void sfdisk_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct sfdisk_state *state = (struct sfdisk_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_sfdisk: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_sfdisk: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_sfdisk (guestfs_h *g,
		const char *device,
		int cyls,
		int heads,
		int sectors,
		char * const* const lines)
{
  struct guestfs_sfdisk_args args;
  struct sfdisk_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_sfdisk") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.device = (char *) device;
  args.cyls = cyls;
  args.heads = heads;
  args.sectors = sectors;
  args.lines.lines_val = (char **) lines;
  for (args.lines.lines_len = 0; lines[args.lines.lines_len]; args.lines.lines_len++) ;
  serial = guestfs__send (g, GUESTFS_PROC_SFDISK,
                     (xdrproc_t) xdr_guestfs_sfdisk_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, sfdisk_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_sfdisk failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_SFDISK, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct write_file_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void write_file_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct write_file_state *state = (struct write_file_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_write_file: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_write_file: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_write_file (guestfs_h *g,
		const char *path,
		const char *content,
		int size)
{
  struct guestfs_write_file_args args;
  struct write_file_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_write_file") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  args.content = (char *) content;
  args.size = size;
  serial = guestfs__send (g, GUESTFS_PROC_WRITE_FILE,
                     (xdrproc_t) xdr_guestfs_write_file_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, write_file_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_write_file failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_WRITE_FILE, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct umount_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void umount_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct umount_state *state = (struct umount_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_umount: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_umount: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_umount (guestfs_h *g,
		const char *pathordevice)
{
  struct guestfs_umount_args args;
  struct umount_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_umount") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.pathordevice = (char *) pathordevice;
  serial = guestfs__send (g, GUESTFS_PROC_UMOUNT,
                     (xdrproc_t) xdr_guestfs_umount_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, umount_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_umount failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_UMOUNT, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct mounts_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_mounts_ret ret;
};

static void mounts_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct mounts_state *state = (struct mounts_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_mounts: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_mounts: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_mounts_ret (xdr, &state->ret)) {
    error (g, "guestfs_mounts: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

char **guestfs_mounts (guestfs_h *g)
{
  struct mounts_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_mounts") == -1) return NULL;

  memset (&state, 0, sizeof state);

  serial = guestfs__send (g, GUESTFS_PROC_MOUNTS, NULL, NULL);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, mounts_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_mounts failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_MOUNTS, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  state.ret.devices.devices_val =
    safe_realloc (g, state.ret.devices.devices_val,
                  sizeof (char *) * (state.ret.devices.devices_len + 1));
  state.ret.devices.devices_val[state.ret.devices.devices_len] = NULL;
  return state.ret.devices.devices_val;
}

struct umount_all_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void umount_all_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct umount_all_state *state = (struct umount_all_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_umount_all: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_umount_all: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_umount_all (guestfs_h *g)
{
  struct umount_all_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_umount_all") == -1) return -1;

  memset (&state, 0, sizeof state);

  serial = guestfs__send (g, GUESTFS_PROC_UMOUNT_ALL, NULL, NULL);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, umount_all_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_umount_all failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_UMOUNT_ALL, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct lvm_remove_all_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void lvm_remove_all_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lvm_remove_all_state *state = (struct lvm_remove_all_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_lvm_remove_all: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_lvm_remove_all: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_lvm_remove_all (guestfs_h *g)
{
  struct lvm_remove_all_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lvm_remove_all") == -1) return -1;

  memset (&state, 0, sizeof state);

  serial = guestfs__send (g, GUESTFS_PROC_LVM_REMOVE_ALL, NULL, NULL);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, lvm_remove_all_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_lvm_remove_all failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_LVM_REMOVE_ALL, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct file_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_file_ret ret;
};

static void file_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct file_state *state = (struct file_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_file: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_file: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_file_ret (xdr, &state->ret)) {
    error (g, "guestfs_file: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

char *guestfs_file (guestfs_h *g,
		const char *path)
{
  struct guestfs_file_args args;
  struct file_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_file") == -1) return NULL;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_FILE,
                     (xdrproc_t) xdr_guestfs_file_args, (char *) &args);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, file_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_file failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_FILE, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  return state.ret.description; /* caller will free */
}

struct command_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_command_ret ret;
};

static void command_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct command_state *state = (struct command_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_command: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_command: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_command_ret (xdr, &state->ret)) {
    error (g, "guestfs_command: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

char *guestfs_command (guestfs_h *g,
		char * const* const arguments)
{
  struct guestfs_command_args args;
  struct command_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_command") == -1) return NULL;

  memset (&state, 0, sizeof state);

  args.arguments.arguments_val = (char **) arguments;
  for (args.arguments.arguments_len = 0; arguments[args.arguments.arguments_len]; args.arguments.arguments_len++) ;
  serial = guestfs__send (g, GUESTFS_PROC_COMMAND,
                     (xdrproc_t) xdr_guestfs_command_args, (char *) &args);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, command_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_command failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_COMMAND, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  return state.ret.output; /* caller will free */
}

struct command_lines_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_command_lines_ret ret;
};

static void command_lines_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct command_lines_state *state = (struct command_lines_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_command_lines: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_command_lines: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_command_lines_ret (xdr, &state->ret)) {
    error (g, "guestfs_command_lines: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

char **guestfs_command_lines (guestfs_h *g,
		char * const* const arguments)
{
  struct guestfs_command_lines_args args;
  struct command_lines_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_command_lines") == -1) return NULL;

  memset (&state, 0, sizeof state);

  args.arguments.arguments_val = (char **) arguments;
  for (args.arguments.arguments_len = 0; arguments[args.arguments.arguments_len]; args.arguments.arguments_len++) ;
  serial = guestfs__send (g, GUESTFS_PROC_COMMAND_LINES,
                     (xdrproc_t) xdr_guestfs_command_lines_args, (char *) &args);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, command_lines_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_command_lines failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_COMMAND_LINES, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  state.ret.lines.lines_val =
    safe_realloc (g, state.ret.lines.lines_val,
                  sizeof (char *) * (state.ret.lines.lines_len + 1));
  state.ret.lines.lines_val[state.ret.lines.lines_len] = NULL;
  return state.ret.lines.lines_val;
}

struct stat_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_stat_ret ret;
};

static void stat_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct stat_state *state = (struct stat_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_stat: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_stat: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_stat_ret (xdr, &state->ret)) {
    error (g, "guestfs_stat: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

struct guestfs_stat *guestfs_stat (guestfs_h *g,
		const char *path)
{
  struct guestfs_stat_args args;
  struct stat_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_stat") == -1) return NULL;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_STAT,
                     (xdrproc_t) xdr_guestfs_stat_args, (char *) &args);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, stat_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_stat failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_STAT, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this */
  return safe_memdup (g, &state.ret.statbuf, sizeof (state.ret.statbuf));
}

struct lstat_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_lstat_ret ret;
};

static void lstat_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct lstat_state *state = (struct lstat_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_lstat: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_lstat: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_lstat_ret (xdr, &state->ret)) {
    error (g, "guestfs_lstat: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

struct guestfs_stat *guestfs_lstat (guestfs_h *g,
		const char *path)
{
  struct guestfs_lstat_args args;
  struct lstat_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_lstat") == -1) return NULL;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_LSTAT,
                     (xdrproc_t) xdr_guestfs_lstat_args, (char *) &args);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, lstat_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_lstat failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_LSTAT, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this */
  return safe_memdup (g, &state.ret.statbuf, sizeof (state.ret.statbuf));
}

struct statvfs_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_statvfs_ret ret;
};

static void statvfs_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct statvfs_state *state = (struct statvfs_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_statvfs: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_statvfs: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_statvfs_ret (xdr, &state->ret)) {
    error (g, "guestfs_statvfs: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

struct guestfs_statvfs *guestfs_statvfs (guestfs_h *g,
		const char *path)
{
  struct guestfs_statvfs_args args;
  struct statvfs_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_statvfs") == -1) return NULL;

  memset (&state, 0, sizeof state);

  args.path = (char *) path;
  serial = guestfs__send (g, GUESTFS_PROC_STATVFS,
                     (xdrproc_t) xdr_guestfs_statvfs_args, (char *) &args);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, statvfs_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_statvfs failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_STATVFS, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this */
  return safe_memdup (g, &state.ret.statbuf, sizeof (state.ret.statbuf));
}

struct tune2fs_l_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_tune2fs_l_ret ret;
};

static void tune2fs_l_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct tune2fs_l_state *state = (struct tune2fs_l_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_tune2fs_l: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_tune2fs_l: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_tune2fs_l_ret (xdr, &state->ret)) {
    error (g, "guestfs_tune2fs_l: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

char **guestfs_tune2fs_l (guestfs_h *g,
		const char *device)
{
  struct guestfs_tune2fs_l_args args;
  struct tune2fs_l_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_tune2fs_l") == -1) return NULL;

  memset (&state, 0, sizeof state);

  args.device = (char *) device;
  serial = guestfs__send (g, GUESTFS_PROC_TUNE2FS_L,
                     (xdrproc_t) xdr_guestfs_tune2fs_l_args, (char *) &args);
  if (serial == -1)
    return NULL;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, tune2fs_l_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_tune2fs_l failed, see earlier error messages");
    return NULL;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_TUNE2FS_L, serial) == -1)
    return NULL;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return NULL;
  }

  /* caller will free this, but we need to add a NULL entry */
  state.ret.superblock.superblock_val =
    safe_realloc (g, state.ret.superblock.superblock_val,
                  sizeof (char *) * (state.ret.superblock.superblock_len + 1));
  state.ret.superblock.superblock_val[state.ret.superblock.superblock_len] = NULL;
  return state.ret.superblock.superblock_val;
}

struct blockdev_setro_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void blockdev_setro_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_setro_state *state = (struct blockdev_setro_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_blockdev_setro: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_blockdev_setro: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_blockdev_setro (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_setro_args args;
  struct blockdev_setro_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_setro") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.device = (char *) device;
  serial = guestfs__send (g, GUESTFS_PROC_BLOCKDEV_SETRO,
                     (xdrproc_t) xdr_guestfs_blockdev_setro_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, blockdev_setro_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_blockdev_setro failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_BLOCKDEV_SETRO, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct blockdev_setrw_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void blockdev_setrw_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_setrw_state *state = (struct blockdev_setrw_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_blockdev_setrw: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_blockdev_setrw: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_blockdev_setrw (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_setrw_args args;
  struct blockdev_setrw_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_setrw") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.device = (char *) device;
  serial = guestfs__send (g, GUESTFS_PROC_BLOCKDEV_SETRW,
                     (xdrproc_t) xdr_guestfs_blockdev_setrw_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, blockdev_setrw_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_blockdev_setrw failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_BLOCKDEV_SETRW, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct blockdev_getro_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_blockdev_getro_ret ret;
};

static void blockdev_getro_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_getro_state *state = (struct blockdev_getro_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_blockdev_getro: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_blockdev_getro: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_blockdev_getro_ret (xdr, &state->ret)) {
    error (g, "guestfs_blockdev_getro: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_blockdev_getro (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_getro_args args;
  struct blockdev_getro_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_getro") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.device = (char *) device;
  serial = guestfs__send (g, GUESTFS_PROC_BLOCKDEV_GETRO,
                     (xdrproc_t) xdr_guestfs_blockdev_getro_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, blockdev_getro_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_blockdev_getro failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_BLOCKDEV_GETRO, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return state.ret.ro;
}

struct blockdev_getss_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_blockdev_getss_ret ret;
};

static void blockdev_getss_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_getss_state *state = (struct blockdev_getss_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_blockdev_getss: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_blockdev_getss: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_blockdev_getss_ret (xdr, &state->ret)) {
    error (g, "guestfs_blockdev_getss: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_blockdev_getss (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_getss_args args;
  struct blockdev_getss_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_getss") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.device = (char *) device;
  serial = guestfs__send (g, GUESTFS_PROC_BLOCKDEV_GETSS,
                     (xdrproc_t) xdr_guestfs_blockdev_getss_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, blockdev_getss_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_blockdev_getss failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_BLOCKDEV_GETSS, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return state.ret.sectorsize;
}

struct blockdev_getbsz_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_blockdev_getbsz_ret ret;
};

static void blockdev_getbsz_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_getbsz_state *state = (struct blockdev_getbsz_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_blockdev_getbsz: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_blockdev_getbsz: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_blockdev_getbsz_ret (xdr, &state->ret)) {
    error (g, "guestfs_blockdev_getbsz: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_blockdev_getbsz (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_getbsz_args args;
  struct blockdev_getbsz_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_getbsz") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.device = (char *) device;
  serial = guestfs__send (g, GUESTFS_PROC_BLOCKDEV_GETBSZ,
                     (xdrproc_t) xdr_guestfs_blockdev_getbsz_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, blockdev_getbsz_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_blockdev_getbsz failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_BLOCKDEV_GETBSZ, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return state.ret.blocksize;
}

struct blockdev_setbsz_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void blockdev_setbsz_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_setbsz_state *state = (struct blockdev_setbsz_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_blockdev_setbsz: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_blockdev_setbsz: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_blockdev_setbsz (guestfs_h *g,
		const char *device,
		int blocksize)
{
  struct guestfs_blockdev_setbsz_args args;
  struct blockdev_setbsz_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_setbsz") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.device = (char *) device;
  args.blocksize = blocksize;
  serial = guestfs__send (g, GUESTFS_PROC_BLOCKDEV_SETBSZ,
                     (xdrproc_t) xdr_guestfs_blockdev_setbsz_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, blockdev_setbsz_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_blockdev_setbsz failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_BLOCKDEV_SETBSZ, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct blockdev_getsz_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_blockdev_getsz_ret ret;
};

static void blockdev_getsz_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_getsz_state *state = (struct blockdev_getsz_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_blockdev_getsz: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_blockdev_getsz: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_blockdev_getsz_ret (xdr, &state->ret)) {
    error (g, "guestfs_blockdev_getsz: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int64_t guestfs_blockdev_getsz (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_getsz_args args;
  struct blockdev_getsz_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_getsz") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.device = (char *) device;
  serial = guestfs__send (g, GUESTFS_PROC_BLOCKDEV_GETSZ,
                     (xdrproc_t) xdr_guestfs_blockdev_getsz_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, blockdev_getsz_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_blockdev_getsz failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_BLOCKDEV_GETSZ, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return state.ret.sizeinsectors;
}

struct blockdev_getsize64_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
  struct guestfs_blockdev_getsize64_ret ret;
};

static void blockdev_getsize64_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_getsize64_state *state = (struct blockdev_getsize64_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_blockdev_getsize64: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_blockdev_getsize64: failed to parse reply error");
      return;
    }
    goto done;
  }
  if (!xdr_guestfs_blockdev_getsize64_ret (xdr, &state->ret)) {
    error (g, "guestfs_blockdev_getsize64: failed to parse reply");
    return;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int64_t guestfs_blockdev_getsize64 (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_getsize64_args args;
  struct blockdev_getsize64_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_getsize64") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.device = (char *) device;
  serial = guestfs__send (g, GUESTFS_PROC_BLOCKDEV_GETSIZE64,
                     (xdrproc_t) xdr_guestfs_blockdev_getsize64_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, blockdev_getsize64_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_blockdev_getsize64 failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_BLOCKDEV_GETSIZE64, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return state.ret.sizeinbytes;
}

struct blockdev_flushbufs_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void blockdev_flushbufs_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_flushbufs_state *state = (struct blockdev_flushbufs_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_blockdev_flushbufs: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_blockdev_flushbufs: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_blockdev_flushbufs (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_flushbufs_args args;
  struct blockdev_flushbufs_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_flushbufs") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.device = (char *) device;
  serial = guestfs__send (g, GUESTFS_PROC_BLOCKDEV_FLUSHBUFS,
                     (xdrproc_t) xdr_guestfs_blockdev_flushbufs_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, blockdev_flushbufs_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_blockdev_flushbufs failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_BLOCKDEV_FLUSHBUFS, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

struct blockdev_rereadpt_state {
  int cb_state;
  struct guestfs_message_header hdr;
  struct guestfs_message_error err;
};

static void blockdev_rereadpt_cb (guestfs_h *g, void *data, XDR *xdr)
{
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  struct blockdev_rereadpt_state *state = (struct blockdev_rereadpt_state *) data;

  if (!xdr_guestfs_message_header (xdr, &state->hdr)) {
    error (g, "guestfs_blockdev_rereadpt: failed to parse reply header");
    return;
  }
  if (state->hdr.status == GUESTFS_STATUS_ERROR) {
    if (!xdr_guestfs_message_error (xdr, &state->err)) {
      error (g, "guestfs_blockdev_rereadpt: failed to parse reply error");
      return;
    }
    goto done;
  }
 done:
  state->cb_state = 1;
  ml->main_loop_quit (ml, g);
}

int guestfs_blockdev_rereadpt (guestfs_h *g,
		const char *device)
{
  struct guestfs_blockdev_rereadpt_args args;
  struct blockdev_rereadpt_state state;
  guestfs_main_loop *ml = guestfs_get_main_loop (g);
  int serial;

  if (check_state (g, "guestfs_blockdev_rereadpt") == -1) return -1;

  memset (&state, 0, sizeof state);

  args.device = (char *) device;
  serial = guestfs__send (g, GUESTFS_PROC_BLOCKDEV_REREADPT,
                     (xdrproc_t) xdr_guestfs_blockdev_rereadpt_args, (char *) &args);
  if (serial == -1)
    return -1;

  state.cb_state = 0;
  guestfs_set_reply_callback (g, blockdev_rereadpt_cb, &state);
  (void) ml->main_loop_run (ml, g);
  guestfs_set_reply_callback (g, NULL, NULL);
  if (!state.cb_state) {
    error (g, "guestfs_blockdev_rereadpt failed, see earlier error messages");
    return -1;
  }

  if (check_reply_header (g, &state.hdr, GUESTFS_PROC_BLOCKDEV_REREADPT, serial) == -1)
    return -1;

  if (state.hdr.status == GUESTFS_STATUS_ERROR) {
    error (g, "%s", state.err.error_message);
    return -1;
  }

  return 0;
}

